fun saveImageToGallery(context: Context, file: File?) {
    file?.let {
        val filename = file.name
        val mimeType = "image/jpeg"
        val values = ContentValues().apply {
            put(MediaStore.Images.Media.DISPLAY_NAME, filename)
            put(MediaStore.Images.Media.MIME_TYPE, mimeType)
            put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
        }

        val resolver = context.contentResolver
        val uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
        
        uri?.let {
            val outputStream: OutputStream? = resolver.openOutputStream(uri)
            val inputStream = FileInputStream(file)

            try {
                inputStream.copyTo(outputStream!!)
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                inputStream.close()
                outputStream?.close()
            }
        }
    }
}


1. 
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.painter.Painter
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import coil.annotation.ExperimentalCoilApi
import coil.compose.rememberImagePainter
import kotlinx.coroutines.*
import okhttp3.ResponseBody
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
import retrofit2.http.Streaming
import retrofit2.http.Url
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream

interface ApiService {
    @Streaming
    @GET
    suspend fun downloadImage(@Url url: String): ResponseBody
}

class MainActivity : ComponentActivity() {
    @OptIn(ExperimentalCoilApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val retrofit = Retrofit.Builder()
            .baseUrl("https://your-image-server-url.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val apiService = retrofit.create(ApiService::class.java)

        setContent {
            ImageSaverApp(apiService)
        }
    }
}

@OptIn(ExperimentalCoilApi::class)
@Composable
fun ImageSaverApp(apiService: ApiService) {
    var imageUrl by remember { mutableStateOf("") }
    var downloadProgress by remember { mutableStateOf(0) }
    var downloading by remember { mutableStateOf(false) }
    var imageLoaded by remember { mutableStateOf(false) }
    var imageFile: File? by remember { mutableStateOf(null) }
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()
    val focusManager = LocalFocusManager.current
    val keyboardController = LocalSoftwareKeyboardController.current

    Scaffold(
        topBar = {
            TopAppBar(title = { Text(text = "Image Saver") })
        }
    ) {
        Column(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            OutlinedTextField(
                value = imageUrl,
                onValueChange = { imageUrl = it },
                label = { Text("Enter Image URL") },
                keyboardOptions = KeyboardOptions.Default.copy(
                    imeAction = ImeAction.Done,
                    keyboardType = KeyboardType.Uri
                ),
                keyboardActions = KeyboardActions(
                    onDone = {
                        focusManager.clearFocus()
                        keyboardController?.hide()
                    }
                ),
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Button(
                    onClick = {
                        coroutineScope.launch {
                            downloadImage(apiService, imageUrl)
                        }
                    },
                    enabled = imageUrl.isNotEmpty() && !downloading,
                    modifier = Modifier
                        .padding(end = 8.dp)
                        .weight(1f)
                ) {
                    Text(text = "Download")
                }
                Button(
                    onClick = {
                        // Cancel download
                        coroutineScope.coroutineContext.cancelChildren()
                        downloading = false
                        downloadProgress = 0
                    },
                    enabled = downloading,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(text = "Cancel")
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (downloading) {
                LinearProgressIndicator(
                    progress = downloadProgress / 100f,
                    modifier = Modifier.fillMaxWidth()
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (imageLoaded) {
                Image(
                    painter = rememberImagePainter(data = imageFile),
                    contentDescription = null,
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(300.dp),
                    contentScale = androidx.compose.ui.layout.ContentScale.Fit
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (imageFile != null) {
                Button(
                    onClick = {
                        // Save image to gallery
                        // You need to handle permissions accordingly
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(text = "Save to Gallery")
                }
            }
        }
    }
}

suspend fun downloadImage(apiService: ApiService, url: String) {
    val response = apiService.downloadImage(url)
    val inputStream: InputStream = response.byteStream()
    val file = File.createTempFile("image_", ".png")
    val outputStream = FileOutputStream(file)
    val buffer = ByteArray(4096)
    var bytesRead: Int
    var totalBytesRead: Long = 0
    val fileSize: Long = response.contentLength()
    var prevProgress = 0

    while (inputStream.read(buffer).also { bytesRead = it } != -1) {
        outputStream.write(buffer, 0, bytesRead)
        totalBytesRead += bytesRead
        val progress = ((totalBytesRead.toFloat() / fileSize) * 100).toInt()
        if (progress != prevProgress) {
            prevProgress = progress
            // Update progress
        }
    }

    outputStream.flush()
    outputStream.close()
    inputStream.close()

    // Set image loaded state
    // You may want to handle this differently based on your UI architecture
}


2. 

mport android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.drawable.BitmapDrawable
import android.os.Bundle
import android.provider.MediaStore
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardActions
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.painter.Painter
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.toBitmap
import coil.annotation.ExperimentalCoilApi
import coil.compose.rememberImagePainter
import coil.request.ImageRequest
import kotlinx.coroutines.*
import okhttp3.ResponseBody
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.GET
import retrofit2.http.Streaming
import retrofit2.http.Url
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream

interface ApiService {
    @Streaming
    @GET
    suspend fun downloadImage(@Url url: String): ResponseBody
}

class MainActivity : ComponentActivity() {
    @OptIn(ExperimentalCoilApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val retrofit = Retrofit.Builder()
            .baseUrl("https://your-image-server-url.com/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        val apiService = retrofit.create(ApiService::class.java)

        setContent {
            ImageSaverApp(apiService)
        }
    }
}

@OptIn(ExperimentalCoilApi::class)
@Composable
fun ImageSaverApp(apiService: ApiService) {
    var imageUrl by remember { mutableStateOf("") }
    var downloadProgress by remember { mutableStateOf(0) }
    var downloading by remember { mutableStateOf(false) }
    var imageLoaded by remember { mutableStateOf(false) }
    var imageBitmap by remember { mutableStateOf<ImageBitmap?>(null) }
    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()
    val focusManager = LocalFocusManager.current
    val keyboardController = LocalSoftwareKeyboardController.current

    Scaffold(
        topBar = {
            TopAppBar(title = { Text(text = "Image Saver") })
        }
    ) {
        Column(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            OutlinedTextField(
                value = imageUrl,
                onValueChange = { imageUrl = it },
                label = { Text("Enter Image URL") },
                keyboardOptions = KeyboardOptions.Default.copy(
                    imeAction = ImeAction.Done,
                    keyboardType = KeyboardType.Uri
                ),
                keyboardActions = KeyboardActions(
                    onDone = {
                        focusManager.clearFocus()
                        keyboardController?.hide()
                    }
                ),
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center
            ) {
                Button(
                    onClick = {
                        coroutineScope.launch {
                            downloadImage(apiService, imageUrl)
                        }
                    },
                    enabled = imageUrl.isNotEmpty() && !downloading,
                    modifier = Modifier
                        .padding(end = 8.dp)
                        .weight(1f)
                ) {
                    Text(text = "Download")
                }
                Button(
                    onClick = {
                        // Cancel download
                        coroutineScope.coroutineContext.cancelChildren()
                        downloading = false
                        downloadProgress = 0
                    },
                    enabled = downloading,
                    modifier = Modifier.weight(1f)
                ) {
                    Text(text = "Cancel")
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (downloading) {
                LinearProgressIndicator(
                    progress = downloadProgress / 100f,
                    modifier = Modifier.fillMaxWidth()
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (imageLoaded) {
                imageBitmap?.let {
                    Image(
                        bitmap = it,
                        contentDescription = null,
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(300.dp),
                        contentScale = androidx.compose.ui.layout.ContentScale.Fit
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (imageBitmap != null) {
                Button(
                    onClick = {
                        saveImageToGallery(context, imageBitmap!!)
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(text = "Save to Gallery")
                }
            }
        }
    }
}

suspend fun downloadImage(apiService: ApiService, url: String) {
    val response = apiService.downloadImage(url)
    val inputStream: InputStream = response.byteStream()
    val file = File.createTempFile("image_", ".png")
    val outputStream = FileOutputStream(file)
    val buffer = ByteArray(4096)
    var bytesRead: Int
    var totalBytesRead: Long = 0
    val fileSize: Long = response.contentLength()
    var prevProgress = 0

    while (inputStream.read(buffer).also { bytesRead = it } != -1) {
        outputStream.write(buffer, 0, bytesRead)
        totalBytesRead += bytesRead
        val progress = ((totalBytesRead.toFloat() / fileSize) * 100).toInt()
        if (progress != prevProgress) {
            prevProgress = progress
            // Update progress
        }
    }

    outputStream.flush()
    outputStream.close()
    inputStream.close()

    // Load downloaded image
    loadDownloadedImage(file)
}

suspend fun loadDownloadedImage(file: File) {
    val bitmap = withContext(Dispatchers.IO) {
        coil.decode.BitmapFactory.decodeFile(file)
    }
    // Set image loaded state
    // You may want to handle this differently based on your UI architecture
}

fun saveImageToGallery(context: Context, imageBitmap: ImageBitmap) {
    if (ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        // Handle permission request
        return
    }

    val savedUri = MediaStore.Images.Media.insertImage(
        context.contentResolver,
        imageBitmap.asDrawable().toBitmap(),
        "Image",
        ""
    )

    if (savedUri != null) {
        Toast.makeText(context, "Image saved to Gallery", Toast.LENGTH_SHORT).show()
    } else {
        Toast.makeText(context, "Failed to save image", Toast.LENGTH_SHORT).show()
    }
}
