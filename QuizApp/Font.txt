package com.example.etchatapplication.repository.firestore

import android.util.Log
import com.example.etchatapplication.model.Group
import com.example.etchatapplication.model.Message
import com.example.etchatapplication.model.User
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
) {

    private val userCollection = firestore.collection("users")
    private val chatsCollection = firestore.collection("chats")
    private val groupCollection = firestore.collection("groups")

    fun getUsersList(onResult: (List<User>) -> Unit) {
        userCollection.get()
            .addOnSuccessListener { result ->
                val users = result.map { it.toObject(User::class.java) }
                onResult(users)
            }
            .addOnFailureListener { exception ->
                exception.printStackTrace()
                onResult(emptyList())
            }
    }

    fun addUser(uid: String, user: User, onResult: (Boolean) -> Unit) {
        userCollection.document(uid)
            .set(user)
            .addOnCompleteListener { task ->
                onResult(task.isSuccessful)
            }
            .addOnFailureListener { exception ->
                exception.printStackTrace()
            }
    }

    fun sendMessage(receiverEmail: String, message: String, onResult: (Boolean) -> Unit) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val senderEmail = currentUser?.email ?: return

        val messageId = UUID.randomUUID().toString()
        val chatMessage = Message(
            id = messageId,
            senderId = senderEmail,
            receiverId = receiverEmail,
            message = message,
            isSent = true,
            timestamp = System.currentTimeMillis()
        )

        // Reference to Firestore document for the sender
        val senderDocRef = chatsCollection
            .document(senderEmail)
            .collection(receiverEmail)
            .document(messageId)

        // Reference to Firestore document for the receiver
        val receiverDocRef = chatsCollection
            .document(receiverEmail)
            .collection(senderEmail)
            .document(messageId)

        // Run a batch write to ensure both documents are updated automatically.
        firestore.runBatch { batch ->
            batch.set(senderDocRef, chatMessage)
            batch.set(receiverDocRef, chatMessage)
        }.addOnCompleteListener { task ->
            onResult(task.isSuccessful)
        }
    }

    fun getMessages(senderEmail: String, receiverEmail: String): Flow<List<Message>> =
        callbackFlow {
            val documentRef = chatsCollection.document(senderEmail)
                .collection(receiverEmail)
                .orderBy("timestamp")

            // Added a snapshot listener to get real-time updates
            val subscription = documentRef.addSnapshotListener { value, _ ->
                if (value != null) {
                    val messages = value.toObjects(Message::class.java)
                    trySend(messages).isSuccess
                }
            }
            // Clean up the listener when the flow is closed
            awaitClose { subscription.remove() }
        }

    fun createGroup(name: String, selectedUsers: List<String>, callback: (String) -> Unit) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val members = selectedUsers + currentUser?.uid
        val groupData = hashMapOf(
            "name" to name,
            "members" to members
        )
        groupCollection.add(groupData)
            .addOnSuccessListener { documentReference ->
                callback(documentReference.id)
            }
            .addOnFailureListener { e ->
                e.printStackTrace()
            }
    }

    fun sendMessageToGroup(groupId: String, senderId: String, content: String) {
        val messageData = hashMapOf(
            "senderId" to senderId,
            "content" to content,
            "timestamp" to FieldValue.serverTimestamp()
        )
        groupCollection.document(groupId)
            .collection("messages").add(messageData)
            .addOnSuccessListener { documentReference ->
                println("Message sent with ID: ${documentReference.id}")
            }
            .addOnFailureListener { e ->
                e.printStackTrace()
            }
    }

    fun getGroupMessages(groupId: String, callback: (List<Message>) -> Unit) {
        groupCollection.document(groupId)
            .collection("messages").orderBy("timestamp").addSnapshotListener { snapshots, e ->
                if (e != null) {
                    e.printStackTrace()
                    return@addSnapshotListener
                }
                if (snapshots != null) {
                    val messages = snapshots.documents.map { doc ->
                        Message(
                            senderId = doc.getString("senderId") ?: "",
                            message = doc.getString("content") ?: "",
                            timestamp = doc.getTimestamp("timestamp").toString().toLong()
                        )
                    }
                    callback(messages)
                }
            }
    }

    // In FirestoreRepository
    fun getGroups(callback: (List<Group>) -> Unit) {
        val currentUser = FirebaseAuth.getInstance().currentUser

        if (currentUser == null) {
            Log.e("FirestoreRepo", "No current user found.")
            return
        }

        groupCollection
            .whereArrayContains("members", currentUser.uid)
            .addSnapshotListener { snapshots, e ->
                if (e != null) {
                    Log.e("FirestoreRepo", "Error fetching groups: ${e.message}", e)
                    return@addSnapshotListener
                }
                if (snapshots != null) {
                    val groups = snapshots.documents.mapNotNull { doc ->
                        try {
                            Group(
                                id = doc.id,
                                name = doc.getString("name") ?: "",
                                members = doc.get("members") as? List<String> ?: emptyList()
                            )
                        } catch (ex: Exception) {
                            Log.e("FirestoreRepo", "Error parsing group document: ${doc.id}", ex)
                            null
                        }
                    }
                    callback(groups)
                } else {
                    Log.w("FirestoreRepo", "No groups found for the current user.")
                    callback(emptyList())
                }
            }
    }
}

package com.example.etchatapplication.ui.screen.group.add

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.etchatapplication.model.Group
import com.example.etchatapplication.model.User
import com.example.etchatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class GroupAddViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _groupName = MutableStateFlow("")
    val groupName: StateFlow<String> = _groupName

    private val _userList = MutableStateFlow<List<User>>(emptyList())
    val userList: StateFlow<List<User>> = _userList

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    val groupList = mutableListOf<String>()

    fun onGroupNameChange(name: String) {
        _groupName.value = name
    }

    init {
        getUserList()
    }

    private fun getUserList() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                firestoreRepository.getUsersList { users ->
                    _userList.value = users
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun createGroup(name: String, selectedUsers: List<String>, callback: (String) -> Unit) {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                firestoreRepository.createGroup(name, selectedUsers) { groupId ->
                    callback(groupId)
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                _isLoading.value = false
            }
        }
    }
}

package com.example.etchatapplication.ui.screen.group.add

import android.widget.Toast
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CheckboxDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.example.etchatapplication.R
import com.example.etchatapplication.model.User
import com.example.etchatapplication.ui.screen.signup.InputTextField
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupAddScreen(innerNavController: NavHostController) {

    val groupAddViewModel = hiltViewModel<GroupAddViewModel>()
    val groupName by groupAddViewModel.groupName.collectAsState()
    val userList by groupAddViewModel.userList.collectAsState()
    val context = LocalContext.current

    var selectedUsers by remember { mutableStateOf(listOf<String>()) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = stringResource(R.string.create_a_group)) },
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { innerNavController.popBackStack() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(Color(0xFF2BCA8D))
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier.padding(paddingValues),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            item {
                Image(
                    painter = painterResource(id = R.drawable.account),
                    contentDescription = null,
                    modifier = Modifier.padding(16.dp)
                )
                InputTextField(
                    value = groupName,
                    onValueChange = { groupAddViewModel.onGroupNameChange(it) },
                    label = { Text(text = stringResource(R.string.enter_group_name)) }
                )
                Button(
                    onClick = {
                        if (groupName.isNotBlank() && selectedUsers.isNotEmpty()) {
                            groupAddViewModel.createGroup(groupName, selectedUsers) { groupId ->
                                Toast.makeText(
                                    context, "Group Created: $groupId",
                                    Toast.LENGTH_SHORT
                                ).show()
                            }
                            innerNavController.popBackStack()
                        } else {
                            Toast.makeText(
                                context,
                                "Please enter a group name and select users",
                                Toast.LENGTH_SHORT
                            ).show()
                        }
                    },
                    colors = ButtonDefaults.buttonColors(Color(0xFF2BCA8D)),
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    Text(text = stringResource(R.string.btn_create))
                }
                Spacer(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(20.dp)
                )
                HorizontalDivider()
            }
            items(userList) { user ->
                val currentUser = FirebaseAuth.getInstance().currentUser
                if (currentUser != null) {
                    if (user.email != currentUser.email) {
                        GroupUserCard(
                            user = user,
                            groupAddViewModel,
                            groupName,
                            selectedUsers
                        ) { isChecked ->
                            selectedUsers = if (isChecked) {
                                selectedUsers + user.email
                            } else {
                                selectedUsers - user.email
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun GroupUserCard(
    user: User,
    groupAddViewModel: GroupAddViewModel,
    groupName: String,
    selectedUsers: List<String>,
    onUserSelect: (Boolean) -> Unit,
) {

    var isChecked by remember { mutableStateOf(selectedUsers.contains(user.email)) }

    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 4.dp)
    ) {
        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(4.dp)) {
            Checkbox(
                checked = isChecked,
                onCheckedChange = {
                    isChecked = it
                    onUserSelect(it)
                },
                colors = CheckboxDefaults.colors(checkedColor = Color(0xFF2BCA8D))
            )
            Image(
                painter = painterResource(id = R.drawable.account),
                contentDescription = null,
                modifier = Modifier
                    .size(60.dp)
                    .padding(4.dp)
            )
            Column(modifier = Modifier.padding(8.dp)) {
                Text(
                    text = "${user.firstname} ${user.lastname}",
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.Black
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.Black
                )
            }
        }
    }
    HorizontalDivider()
}

package com.example.etchatapplication.ui.screen.group.chat

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.example.etchatapplication.model.Message

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupChatScreen(groupId: String, innerNavController: NavHostController) {
    val groupChatViewModel = hiltViewModel<GroupChatViewModel>()
    val messages by groupChatViewModel.messages.collectAsState()
    val newMessage by groupChatViewModel.newMessage.collectAsState()

    LaunchedEffect(groupId) {
        groupChatViewModel.loadMessages(groupId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = "Group Chat") },
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "Back",
                        modifier = Modifier.clickable { innerNavController.popBackStack() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(Color(0xFF2BCA8D))
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    groupChatViewModel.sendMessage(groupId)
                },
                containerColor = Color(0xFF2BCA8D)
            ) {
                Icon(imageVector = Icons.AutoMirrored.Filled.Send, contentDescription = "Send")
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize()
        ) {
            LazyColumn(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.Top
            ) {
                items(messages) { message ->
                    MessageCard(message = message)
                }
            }
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                TextField(
                    value = newMessage,
                    onValueChange = { groupChatViewModel.updateMessage(it) },
                    label = { Text("Enter message") },
                    modifier = Modifier.weight(1f),
                    singleLine = true
                )
            }
        }
    }
}

@Composable
fun MessageCard(message: Message) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(text = message.senderId, style = MaterialTheme.typography.labelMedium)
            Text(text = message.message, style = MaterialTheme.typography.bodyMedium)
            Text(text = message.timestamp.toString(), style = MaterialTheme.typography.labelLarge)
        }
    }
}
package com.example.etchatapplication.ui.screen.group.chat

import androidx.lifecycle.ViewModel
import com.example.etchatapplication.model.Message
import com.example.etchatapplication.repository.firestore.FirestoreRepository
import com.google.firebase.auth.FirebaseAuth
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import javax.inject.Inject

@HiltViewModel
class GroupChatViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {
    private val _messages = MutableStateFlow<List<Message>>(emptyList())
    val messages: StateFlow<List<Message>> = _messages

    private val _newMessage = MutableStateFlow("")
    val newMessage: StateFlow<String> = _newMessage

    fun loadMessages(groupId: String) {
        firestoreRepository.getGroupMessages(groupId) { messages ->
            _messages.value = messages
        }
    }

    fun sendMessage(groupId: String) {
        val senderId = FirebaseAuth.getInstance().currentUser?.uid ?: ""
        val content = _newMessage.value
        if (content.isNotBlank()) {
            firestoreRepository.sendMessageToGroup(groupId, senderId, content)
            _newMessage.value = ""
        }
    }

    fun updateMessage(message: String) {
        _newMessage.value = message
    }
}
package com.example.etchatapplication.ui.screen.group.list

import android.util.Log
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.example.etchatapplication.model.Group

@Composable
fun GroupScreen(innerNavController: NavHostController) {

    val groupViewModel = hiltViewModel<GroupViewModel>()
    val groups by groupViewModel.groups.collectAsState()
    Log.d("GROUPS", "GroupScreen: $groups")

    LazyColumn(
        modifier = Modifier.padding(16.dp).fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        item {
            Text(
                "Groups",
                color = Color.Black,
                modifier = Modifier.padding(8.dp),
                style = MaterialTheme.typography.bodyMedium
            )
        }
        items(groups) { group ->
            GroupCard(group = group) { selectedGroup ->
                // Navigate to GroupChatScreen with group ID
                innerNavController.navigate("group_chat_screen/${selectedGroup.id}")
            }
        }
    }
}


@Composable
fun GroupCard(group: Group, onClick: (Group) -> Unit) {
    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 4.dp)
            .clickable {
                onClick(group)
            }
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = group.name,
                style = MaterialTheme.typography.titleMedium,
                color = Color.Black
            )
            Text(
                text = group.members.joinToString(", "),
                style = MaterialTheme.typography.bodyMedium,
                color = Color.Black
            )
        }
    }
    HorizontalDivider()
}

package com.example.etchatapplication.ui.screen.group.list

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.etchatapplication.model.Group
import com.example.etchatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class GroupViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _groups = MutableStateFlow<List<Group>>(emptyList())
    val groups: StateFlow<List<Group>> = _groups

    init {
        getGroups()
    }

    private fun getGroups() {
        viewModelScope.launch {
            try {
                firestoreRepository.getGroups { groupList ->
                    Log.d("GroupViewModel", "Fetched groups: $groupList")
                    _groups.value = groupList
                }
            } catch (e: Exception) {
                Log.e("GroupViewModel", "Error fetching groups: ${e.message}", e)
            }
        }
    }
}

package com.example.etchatapplication.ui.screen

import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.example.etchatapplication.CONSTANTS.CHAT_SCREEN
import com.example.etchatapplication.CONSTANTS.GROUP_ADD_SCREEN
import com.example.etchatapplication.CONSTANTS.GROUP_DETAIL_SCREEN
import com.example.etchatapplication.CONSTANTS.GROUP_SCREEN
import com.example.etchatapplication.CONSTANTS.HOME_SCREEN
import com.example.etchatapplication.CONSTANTS.SETTINGS_SCREEN
import com.example.etchatapplication.CONSTANTS.USERS_LIST_SCREEN
import com.example.etchatapplication.R
import com.example.etchatapplication.model.BottomNavItem
import com.example.etchatapplication.ui.screen.chat.ChatScreen
import com.example.etchatapplication.ui.screen.group.list.GroupScreen
import com.example.etchatapplication.ui.screen.group.add.GroupAddScreen
import com.example.etchatapplication.ui.screen.group.chat.GroupChatScreen
import com.example.etchatapplication.ui.screen.group.detail.GroupDetailScreen
import com.example.etchatapplication.ui.screen.home.HomeScreen
import com.example.etchatapplication.ui.screen.settings.SettingsScreen
import com.example.etchatapplication.ui.screen.users.UserListScreen

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(navController: NavHostController, darkTheme: Boolean, darkThemeChange: () -> Unit) {

    val innerNavController = rememberNavController()
    val navBackStackEntry by innerNavController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route

    Surface {
        Scaffold(
            topBar = {
                if (currentRoute !in listOf(
                        USERS_LIST_SCREEN, "$CHAT_SCREEN/{userId}", GROUP_ADD_SCREEN
                    )
                ) {
                    TopAppBar(
                        title = { Text(text = stringResource(id = R.string.talk_hub)) },
                        colors = TopAppBarDefaults.topAppBarColors(Color(0xFF2BCA8D))
                    )
                }
            },
            bottomBar = {
                if (currentRoute !in listOf(
                        USERS_LIST_SCREEN, "$CHAT_SCREEN/{userId}", GROUP_ADD_SCREEN
                    )
                ) {
                    BottomNavigationBar(navController = innerNavController)
                }
            }
        ) { paddingValues ->
            NavHostContainer(
                navController = navController,
                innerNavController = innerNavController,
                padding = paddingValues,
                darkTheme = darkTheme,
                darkThemeChange = darkThemeChange
            )
        }
    }
}

@Composable
fun NavHostContainer(
    navController: NavHostController,
    innerNavController: NavHostController,
    padding: PaddingValues,
    darkTheme: Boolean,
    darkThemeChange: () -> Unit,
) {
    NavHost(
        navController = innerNavController,
        startDestination = HOME_SCREEN,
        modifier = Modifier.padding(padding)
    ) {
        composable(HOME_SCREEN) {
            HomeScreen(innerNavController)
        }
        composable(GROUP_SCREEN) {
            GroupScreen(innerNavController)
        }
        composable(SETTINGS_SCREEN) {
            SettingsScreen(navController, darkTheme, darkThemeChange)
        }
        composable(route = USERS_LIST_SCREEN) {
            UserListScreen(innerNavController)
        }
        composable("$CHAT_SCREEN/{userId}") { navBackStack ->
            val userId = navBackStack.arguments?.getString("userId")
            ChatScreen(innerNavController, userId)
        }
        composable(GROUP_ADD_SCREEN) {
            GroupAddScreen(innerNavController)
        }
        composable(GROUP_DETAIL_SCREEN) {
            GroupDetailScreen(innerNavController)
        }
        composable(
            "group_chat_screen/{groupId}",
            arguments = listOf(navArgument("groupId") { type = NavType.StringType })
            ) { backStackEntry ->
            val groupId = backStackEntry.arguments?.getString("groupId") ?: return@composable
            GroupChatScreen(groupId = groupId , innerNavController = innerNavController )
        }
    }
}

@Composable
fun BottomNavigationBar(navController: NavHostController) {
    val bottomNavItem = listOf(
        BottomNavItem(
            label = stringResource(R.string.groups),
            icon = R.drawable.group,
            route = GROUP_SCREEN
        ),
        BottomNavItem(
            label = stringResource(R.string.home),
            icon = R.drawable.home,
            route = HOME_SCREEN
        ),
        BottomNavItem(
            label = stringResource(id = R.string.settings),
            icon = R.drawable.settings,
            route = SETTINGS_SCREEN
        )
    )

    BottomAppBar(
        containerColor = Color.LightGray,
        contentColor = Color.White,
        tonalElevation = 8.dp
    ) {
        val navBackStackEntry by navController.currentBackStackEntryAsState()
        val currentRoute = navBackStackEntry?.destination?.route
        bottomNavItem.forEach { bottomNavItem ->
            NavigationBarItem(
                selected = currentRoute == bottomNavItem.route,
                onClick = { navController.navigate(bottomNavItem.route) },
                icon = {
                    Image(
                        painter = painterResource(id = bottomNavItem.icon),
                        contentDescription = bottomNavItem.label
                    )
                },
                label = { Text(text = bottomNavItem.label, color = Color.Black) },
                alwaysShowLabel = false
            )
        }
    }
}

