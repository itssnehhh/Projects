package com.example.chatapplication.repository.auth

import com.example.chatapplication.model.User
import com.example.chatapplication.repository.firestore.FirestoreRepository
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.UserProfileChangeRequest
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirebaseAuthRepository @Inject constructor(
    private val auth: FirebaseAuth,
    private val firestoreRepository: FirestoreRepository
) {
    fun logIn(email: String, password: String, onResult: (Boolean) -> Unit) {
        auth.signInWithEmailAndPassword(email, password)
            .addOnCompleteListener { logIn ->
                onResult(logIn.isSuccessful)
            }
    }

    fun signUp(
        fName: String,
        lName: String,
        email: String,
        password: String,
        imageUrl: String,
        onResult: (Boolean) -> Unit
    ) {
        auth.createUserWithEmailAndPassword(email, password).addOnCompleteListener { signUp ->
            if (signUp.isSuccessful) {
                val user = auth.currentUser
                user?.let {
                    val userProfile = UserProfileChangeRequest.Builder()
                        .setDisplayName("$fName $lName")
                        .build()
                    it.updateProfile(userProfile).addOnCompleteListener { profileUpdate ->
                        if (profileUpdate.isSuccessful) {
                            val userDetails = User(
                                id = it.uid,
                                firstname = fName,
                                lastname = lName,
                                email = email,
                                image = imageUrl
                            )
                            firestoreRepository.addUser(it.uid, userDetails) { firestoreUpdate ->
                                onResult(firestoreUpdate)
                            }
                        } else {
                            onResult(false)
                        }
                    }
                }
            } else {
                onResult(false)
            }
        }
    }

    fun getCurrentUser() = auth.currentUser

    fun logOut() {
        auth.signOut()
    }
}

package com.example.chatapplication.repository.firestore

import android.net.Uri
import android.util.Log
import com.example.chatapplication.model.ChatRoom
import com.example.chatapplication.model.Group
import com.example.chatapplication.model.Message
import com.example.chatapplication.model.User
import com.example.chatapplication.repository.storage.StorageRepository
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirestoreRepository @Inject constructor(
    private val firestore: FirebaseFirestore,
    private val storageRepository: StorageRepository,
) {

    private val userCollection = firestore.collection("users")
    private val groupCollection = firestore.collection("groups")
    private val chatRoomCollection = firestore.collection("chatrooms")

    fun addUser(uid: String, user: User, onResult: (Boolean) -> Unit) {
        userCollection.document(uid)
            .set(user)
            .addOnCompleteListener { task ->
                onResult(task.isSuccessful)
            }
            .addOnFailureListener { exception ->
                exception.printStackTrace()
                onResult(false)
            }
    }

    fun getUsersList(onResult: (List<User>) -> Unit) {
        userCollection.get()
            .addOnSuccessListener { result ->
                val users = result.map { it.toObject(User::class.java) }
                onResult(users)
            }
            .addOnFailureListener { exception ->
                exception.printStackTrace()
                onResult(emptyList())
            }
    }

    fun getUserDetails(userId: String, callback: (User) -> Unit) {
        userCollection.document(userId).get().addOnSuccessListener { document ->
            if (document != null && document.exists()) {
                val firstName = document.getString("firstname") ?: ""
                val lastName = document.getString("lastname") ?: ""
                val imageUrl = document.getString("image") ?: ""
                val user = User(userId, firstName, lastName, imageUrl)
                callback(user)
            } else {
                callback(User(userId, "Unknown", "", ""))
            }
        }.addOnFailureListener {
            callback(User(userId, "Unknown", "", ""))
        }
    }

    suspend fun sendMessageWithImage(
        receiverId: String,
        message: String = "",
        imageUri: Uri,
        onResult: (Boolean) -> Unit,
    ) {
        try {
            val imageUrl = storageRepository.uploadImage(imageUri)
            sendMessageToRoom(receiverId, message, imageUrl, onResult)
        } catch (e: Exception) {
            onResult(false)
        }
    }

    fun getOrCreateChatRoom(receiverId: String, onComplete: (String?) -> Unit) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val senderId = currentUser?.uid ?: return

        // Query to find existing chat rooms where the current user is a participant
        chatRoomCollection
            .whereArrayContains("participants", senderId)
            .get()
            .addOnSuccessListener { result ->
                var existingChatRoomId: String? = null
                for (document in result) {
                    val participants = document.get("participants") as? List<String> ?: continue
                    if (participants.contains(receiverId)) {
                        existingChatRoomId = document.id
                        break
                    }
                }

                if (existingChatRoomId != null) {
                    // Existing chat room with both participants
                    onComplete(existingChatRoomId)
                } else {
                    // No existing chat room, create a new one
                    val newChatRoomRef = chatRoomCollection.document() // Generate new document reference
                    val newChatRoom = ChatRoom(
                        chatroomId = newChatRoomRef.id, // Use the generated UID
                        lastMessage = "",
                        participants = listOf(senderId, receiverId)
                    )
                    newChatRoomRef.set(newChatRoom).addOnCompleteListener { task ->
                        onComplete(if (task.isSuccessful) newChatRoomRef.id else null)
                    }
                }
            }
            .addOnFailureListener { exception ->
                Log.d("FirebaseRepository", "Error checking existing chat room", exception)
                onComplete(null)
            }
    }

    fun markMessageAsRead(chatRoomId: String, messageId: String, userId: String) {
        val messageRef = chatRoomCollection.document(chatRoomId).collection("messages").document(messageId)
        messageRef.update("readBy", FieldValue.arrayUnion(userId))
    }

    fun getUnreadMessageCount(chatRoomId: String, userId: String, callback: (Int) -> Unit) {
        chatRoomCollection.document(chatRoomId).collection("messages")
            .whereArrayContains("readBy", userId)
            .get()
            .addOnSuccessListener { querySnapshot ->
                val unreadCount = querySnapshot.size()
                callback(unreadCount)
            }
            .addOnFailureListener {
                callback(0)
            }
    }

    fun sendMessageToRoom(
        chatRoomId: String,
        message: String,
        imageUrl: String?,
        onResult: (Boolean) -> Unit,
    ) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val senderId = currentUser?.uid ?: return

        // Generate a unique ID for the message
        val messageId = chatRoomCollection.document(chatRoomId)
            .collection("messages")
            .document().id

        val chatMessage = Message(
            messageId = messageId,
            message = message,
            imageUrl = imageUrl ?: "",
            senderId = senderId,
            timestamp = System.currentTimeMillis(),
            isSent = true
        )

        val messageRef = chatRoomCollection.document(chatRoomId)
            .collection("messages")
            .document(messageId)

        firestore.runTransaction { transition ->
            val chatRoomRef = chatRoomCollection.document(chatRoomId)
            transition.set(messageRef, chatMessage)
            transition.update(chatRoomRef, "lastMessage", message)
        }.addOnCompleteListener { task ->
            if (task.isSuccessful) {
                Log.d("FirebaseRepository", "Message sent successfully")
            } else {
                Log.e("FirebaseRepository", "Failed to send message", task.exception)
            }
            onResult(task.isSuccessful)
        }
    }

    fun getMessageFromChatRoom(chatRoomId: String): Flow<List<Message>> = callbackFlow {
        val messageRef = chatRoomCollection.document(chatRoomId)
            .collection("messages")
            .orderBy("timestamp")

        val subscription = messageRef.addSnapshotListener { value, error ->
            if (error != null) {
                Log.e("FirestoreRepository", "Error getting messages", error)
                return@addSnapshotListener
            }
            if (value != null) {
                val message = value.toObjects(Message::class.java)
                Log.d("FirebaseRepository", "Fetched MessageList :-${message.size}")
                trySend(message).isSuccess
            }
        }
        awaitClose { subscription.remove() }
    }

    fun getRoomChats(): Flow<List<ChatRoom>> = callbackFlow {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val senderId = currentUser?.uid
        val subscription =
            chatRoomCollection.whereArrayContains(
                "participants",
                senderId ?: return@callbackFlow
            )
                .addSnapshotListener { value, error ->
                    if (error != null) {
                        Log.e("FirebaseRepository", "Error fetching room chats", error)
                        return@addSnapshotListener
                    }

                    if (value != null) {
                        val chatRooms = value.toObjects(ChatRoom::class.java)
                        Log.d("FirebaseRepo", "Chat room fetched :- ${chatRooms.size}")
                        chatRooms.forEach {
                            Log.d(
                                "FirestoreRepository",
                                "Chat Room ID: ${it.chatroomId}, Participants: ${it.participants}"
                            )
                        }
                        trySend(chatRooms).isSuccess
                    } else {
                        Log.d("FirestoreRepository", "No chat rooms found")
                    }
                }
        awaitClose { subscription.remove() }
    }

    //Group Create
    fun createGroup(name: String, selectedUsers: List<String>) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val currentUserId = currentUser?.uid
        val members = selectedUsers + currentUserId
        val group = Group(
            id = "",  // We'll set the ID after creating the document reference
            name = name,
            users = members,
            createdBy = currentUserId.toString()
        )

        val groupDocRef =
            groupCollection.document()  // Create a document reference without writing the data
        group.id = groupDocRef.id  // Set the document ID in the group object

        groupDocRef.set(group)
            .addOnSuccessListener {
                Log.d("GROUP_ID", "createGroup: ${group.id}")
            }
            .addOnFailureListener { e ->
                e.printStackTrace()
            }
    }

    // Get GroupList
    fun getGroups(callback: (List<Group>) -> Unit) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        if (currentUser == null) {
            Log.e("FirestoreRepo", "No current user found.")
            return
        }

        groupCollection
            .whereArrayContains("users", currentUser.uid)
            .addSnapshotListener { snapshots, e ->
                if (e != null) {
                    Log.e("FirestoreRepo", "Error fetching groups: ${e.message}", e)
                    return@addSnapshotListener
                }
                if (snapshots != null) {
                    val groups = snapshots.documents.mapNotNull { doc ->
                        try {
                            Group(
                                id = doc.id,
                                name = doc.getString("name") ?: "",
                                users = doc.get("members") as? List<String> ?: emptyList()
                            )
                        } catch (ex: Exception) {
                            Log.e("FirestoreRepo", "Error parsing group document: ${doc.id}", ex)
                            null
                        }
                    }
                    callback(groups)
                } else {
                    Log.w("FirestoreRepo", "No groups found for the current user.")
                    callback(emptyList())
                }
            }
    }

    fun sendMessageToGroup(
        groupId: String,
        senderId: String,
        content: String,
        imageUrl: String? = null,
    ) {
        val messageData = hashMapOf(
            "senderId" to senderId,
            "content" to content,
            "imageUrl" to (imageUrl ?: ""),
            "timestamp" to System.currentTimeMillis()
        )
        groupCollection.document(groupId)
            .collection("messages").add(messageData)
            .addOnSuccessListener { documentReference ->
                println("Message sent with ID: ${documentReference.id}")
            }
            .addOnFailureListener { e ->
                e.printStackTrace()
            }
    }

    fun uploadImage(uri: Uri, onSuccess: (String) -> Unit) {
        val storageRef =
            FirebaseStorage.getInstance().reference.child("images/${uri.lastPathSegment}")
        storageRef.putFile(uri)
            .addOnSuccessListener {
                storageRef.downloadUrl.addOnSuccessListener { uri ->
                    onSuccess(uri.toString())
                }
            }
            .addOnFailureListener { e ->
                e.printStackTrace()
            }
    }

    fun getGroupMessages(groupId: String, callback: (List<Message>) -> Unit) {
        groupCollection.document(groupId)
            .collection("messages").orderBy("timestamp").addSnapshotListener { snapshots, e ->
                if (e != null) {
                    e.printStackTrace()
                    return@addSnapshotListener
                }
                if (snapshots != null) {
                    val messages = snapshots.documents.map { doc ->
                        Message(
                            senderId = doc.getString("senderId") ?: "",
                            message = doc.getString("content") ?: "",
                            timestamp = doc.getLong("timeStamp") ?: 0L,
                            imageUrl = doc.getString("imageUrl") ?: ""
                        )
                    }
                    callback(messages)
                }
            }
    }

    fun getGroupDetails(groupId: String, onComplete: (Group?) -> Unit) {
        groupCollection.document(groupId).get().addOnSuccessListener { document ->
            val group = document.toObject(Group::class.java)
            onComplete(group)
        }
    }

    fun exitGroup(groupId: String, onComplete: (Boolean) -> Unit) {
        val currentUser = FirebaseAuth.getInstance().currentUser
        val userId = currentUser?.uid

        val groupRef = groupCollection.document(groupId)
        groupRef.get().addOnSuccessListener { document ->
            val group = document.toObject(Group::class.java)
            if (userId == group?.createdBy) {
                groupRef.delete().addOnSuccessListener {
                    onComplete(true)
                }
            } else {
                groupRef.update("users", FieldValue.arrayRemove(userId))
                    .addOnSuccessListener { onComplete(true) }
                    .addOnFailureListener { onComplete(false) }
            }
        }
    }

}

package com.example.chatapplication.repository.storage

import android.net.Uri
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.tasks.await
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class StorageRepository @Inject constructor() {

    private val storageReference = FirebaseStorage.getInstance().reference

        suspend fun uploadProfilePicture(uri: Uri): String {
            val storageRef = storageReference.child("profile_images/${UUID.randomUUID()}.jpg")
            val uploadTask = storageRef.putFile(uri).await()
            return storageRef.downloadUrl.await().toString()
        }


    suspend fun uploadImage(uri: Uri): String {
        val imageRef = storageReference.child("chat_images/${UUID.randomUUID()}.jpg")
        val uploadTask = imageRef.putFile(uri).await()
        return imageRef.downloadUrl.await().toString()
    }
}

package com.example.chatapplication.ui.screen.chat

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.AsyncImagePainter
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.model.Message
import com.example.chatapplication.ui.theme.CustomGreen
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatScreen(innerNavController: NavHostController, userId: String?) {

    val chatViewModel = hiltViewModel<ChatViewModel>()
    val textMessage by chatViewModel.textMessage.collectAsState()
    val messages by chatViewModel.messages.collectAsState()
    val userDetails by chatViewModel.userDetails.collectAsState()

    LaunchedEffect(userId) {
        if (userId != null) {
            chatViewModel.getOrCreateRoom(userId)
            chatViewModel.getUserDetails(userId)
        }
    }

    val launcher =
        rememberLauncherForActivityResult(contract = ActivityResultContracts.GetContent()) { uri: Uri? ->
            if (uri != null) {
                chatViewModel.uploadImageAndSendMessage(uri, textMessage)
            }
            chatViewModel.onImageUrlChange(uri)
        }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Image(
                            painter = rememberAsyncImagePainter(model = userDetails?.image, placeholder = painterResource(
                                id = R.drawable.account
                            )),
                            contentDescription = "",
                            modifier = Modifier
                                .size(60.dp)
                                .padding(4.dp)
                                .border(1.dp, Color.DarkGray, CircleShape)
                        )
                        Text(
                            text = "${userDetails?.firstname} ${userDetails?.lastname}",
                            color = Color.White,
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(8.dp)
                        )
                    }
                },
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { innerNavController.popBackStack() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(CustomGreen)
            )
        },
        bottomBar = {
            BottomAppBar(containerColor = Color.LightGray) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    TextField(
                        value = textMessage,
                        onValueChange = { chatViewModel.onTextMessageChange(it) },
                        maxLines = 4,
                        placeholder = {
                            Text(
                                text = stringResource(R.string.enter_a_message),
                                color = Color.DarkGray
                            )
                        },
                        colors = TextFieldDefaults.colors(
                            focusedContainerColor = Color.White,
                            unfocusedContainerColor = Color.White,
                            unfocusedIndicatorColor = Color.White,
                            focusedIndicatorColor = Color.White,
                            focusedTextColor = Color.Black,
                            unfocusedTextColor = Color.Black
                        ),
                        modifier = Modifier
                            .weight(1f)
                            .padding(4.dp)
                            .clip(CardDefaults.shape)
                    )
                    Image(
                        painter = painterResource(id = R.drawable.media),
                        contentDescription = "",
                        modifier = Modifier
                            .size(40.dp)
                            .padding(4.dp)
                            .clickable {
                                launcher.launch("image/*")
                            }
                    )
                    Image(
                        imageVector = Icons.AutoMirrored.Filled.Send,
                        contentDescription = "",
                        modifier = Modifier
                            .size(40.dp)
                            .padding(4.dp)
                            .clickable {
                                chatViewModel.sendMessage(textMessage)
                            }
                    )
                }
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Image(
                painter = painterResource(id = R.drawable.bg),
                contentDescription = "",
                contentScale = ContentScale.Crop,
                modifier = Modifier
                    .fillMaxSize()
            )
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(8.dp)
            ) {
                items(messages) { message ->
                    ChatCard(message = message)
                }
            }
        }
    }
}

@Composable
fun ChatCard(message: Message) {

    val isCurrentUser = message.senderId == FirebaseAuth.getInstance().currentUser?.uid
    val backgroundColor = if (isCurrentUser) CustomGreen else Color.Gray

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = if (isCurrentUser) Arrangement.End else Arrangement.Start,
    ) {
        if (message.message.isNotBlank())
            Card(
                colors = CardDefaults.cardColors(backgroundColor),
                modifier = Modifier
                    .padding(horizontal = 8.dp)
                    .clip(MaterialTheme.shapes.medium)
            ) {
                Text(
                    text = message.message,
                    color = Color.White,
                    modifier = Modifier.padding(8.dp)
                )
            }
        if (message.imageUrl?.isNotBlank() == true) {
            val painter = rememberAsyncImagePainter(message.imageUrl, placeholder = painterResource(id = R.drawable.account))
            Box {
                if (painter.state is AsyncImagePainter.State.Loading) {
                    CircularProgressIndicator(
                        color = CustomGreen,
                        modifier = Modifier
                            .padding(16.dp)
                            .align(Alignment.Center)
                    )
                }
                Image(
                    painter = painter,
                    contentDescription = null,
                    modifier = Modifier.size(120.dp)
                )
            }
        }
    }
}

package com.example.chatapplication.ui.screen.chat

import android.net.Uri
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.model.Message
import com.example.chatapplication.model.User
import com.example.chatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class ChatViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository,
) : ViewModel() {

    private val _textMessage = MutableStateFlow("")
    val textMessage: StateFlow<String> = _textMessage

    private val _chatRoomId = MutableStateFlow<String?>(null)

    private val _image = MutableStateFlow<Uri?>(Uri.parse(""))
    val image: StateFlow<Uri?> = _image

    private val _messages = MutableStateFlow<List<Message>>(emptyList())
    val messages: StateFlow<List<Message>> = _messages

    fun onTextMessageChange(text: String) {
        _textMessage.value = text
    }

    fun onImageUrlChange(imageUrl: Uri?) {
        _image.value = imageUrl
    }

    fun getOrCreateRoom(receiverId: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.getOrCreateChatRoom(receiverId) { chatRoomId ->
                    Log.d("ChatViewModel", "Chat room ID: $chatRoomId")
                    if (chatRoomId != null) {
                        _chatRoomId.value = chatRoomId
                        observeMessage(chatRoomId)
                    } else {
                        Log.e("ChatViewModel", "Failed to get or create chat room")
                    }
                }
            }
        }
    }

    fun sendMessage(message: String) {
        val chatRoomId = _chatRoomId.value ?: return
        val messageText = message.trim()
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                if (messageText.isNotBlank()) {
                    firestoreRepository.sendMessageToRoom(
                        chatRoomId,
                        messageText,
                        _image.value.toString()
                    ) { success ->
                        if (success) {
                            _textMessage.value = ""
                            _image.value = Uri.parse("")
                        } else {
                            Log.e("ChatViewModel", "Failed to send message")
                        }
                    }
                }
            }
        }
    }

    fun uploadImageAndSendMessage(imageUri: Uri, textMessage: String) {
        val chatRoomId = _chatRoomId.value ?: return
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.sendMessageWithImage(
                    chatRoomId,
                    textMessage,
                    imageUri
                ) { success ->
                    if (success) {
                        _textMessage.value = ""
                        _image.value = Uri.parse("")
                    }
                }
            }
        }
    }

    private fun observeMessage(chatRoomId: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.getMessageFromChatRoom(chatRoomId).collect { messages ->
                    _messages.value = messages
                    println(messages)
                }
            }
        }
    }

    private val _userDetails = MutableStateFlow<User?>(null)
    val userDetails: StateFlow<User?> = _userDetails

    fun getUserDetails(userId: String) {
        viewModelScope.launch {
            firestoreRepository.getUserDetails(userId) { user ->
                _userDetails.value = user
            }
        }
    }
}

--------------------------------------------------------------------
package com.example.chatapplication.ui.screen.group.add

import android.widget.Toast
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CheckboxDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.model.User
import com.example.chatapplication.ui.components.InputTextField
import com.example.chatapplication.ui.components.LoadingDialog
import com.example.chatapplication.ui.theme.CustomGreen
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupAddScreen(innerNavController: NavHostController) {

    val groupAddViewModel = hiltViewModel<GroupAddViewModel>()
    val groupName by groupAddViewModel.groupName.collectAsState()
    val userList by groupAddViewModel.userList.collectAsState()
    val isLoading by groupAddViewModel.isLoading.collectAsState()
    var selectedUsers by remember { mutableStateOf(listOf<String>()) }
    val context = LocalContext.current

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = stringResource(R.string.create_a_group),
                        color = Color.White,
                        style = MaterialTheme.typography.titleMedium
                    )
                },
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { innerNavController.popBackStack() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(CustomGreen)
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier.padding(paddingValues),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            item {
                Image(
                    painter = painterResource(id = R.drawable.account),
                    contentDescription = "",
                    modifier = Modifier.padding(16.dp)
                )
                InputTextField(
                    value = groupName,
                    onValueChange = { groupAddViewModel.onGroupNameChange(it) },
                    label = { Text(text = stringResource(R.string.enter_group_name)) }
                )
                Button(
                    onClick = {
                        when {
                            groupName.isEmpty() -> {
                                Toast.makeText(
                                    context,
                                    context.getString(R.string.group_name_toast),
                                    Toast.LENGTH_SHORT
                                ).show()
                            }

                            selectedUsers.isEmpty() -> {
                                Toast.makeText(
                                    context,
                                    context.getString(R.string.select_member_toast),
                                    Toast.LENGTH_SHORT
                                ).show()
                            }

                            else -> {
                                groupAddViewModel.createGroup(groupName, selectedUsers)
                                innerNavController.popBackStack()
                                Toast.makeText(
                                    context,
                                    context.getString(R.string.group_created), Toast.LENGTH_SHORT
                                ).show()
                            }
                        }
                    },
                    colors = ButtonDefaults.buttonColors(CustomGreen),
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    Text(text = stringResource(R.string.btn_create))
                }
                Spacer(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(20.dp)
                )
                Text(
                    text = stringResource(R.string.select_the_users),
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp),
                    textAlign = TextAlign.Start,
                    color = Color.DarkGray,
                    style = MaterialTheme.typography.bodyMedium
                )
                HorizontalDivider()
            }
            items(userList) { user ->
                val currentUser = FirebaseAuth.getInstance().currentUser
                if (currentUser != null) {
                    if (user.id != currentUser.uid) {
                        GroupUserCard(user = user, selectedUsers) { isChecked ->
                            selectedUsers = if (isChecked) {
                                selectedUsers + user.id
                            } else {
                                selectedUsers - user.id
                            }
                        }
                    }
                }
            }
        }
        LoadingDialog(isLoading = isLoading)
    }
}

@Composable
fun GroupUserCard(
    user: User,
    selectedUser: List<String>,
    onUserSelected: (Boolean) -> Unit,
) {

    var isChecked by remember { mutableStateOf(selectedUser.contains(user.email)) }

    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 4.dp)
    ) {
        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(4.dp)) {
            Checkbox(
                checked = isChecked,
                onCheckedChange = {
                    isChecked = it
                    onUserSelected(it)
                },
                colors = CheckboxDefaults.colors(checkedColor = CustomGreen)
            )
            Image(
                painter = rememberAsyncImagePainter(
                    model = user.image, placeholder = painterResource(
                        id = R.drawable.account
                    )
                ),
                contentDescription = "",
                modifier = Modifier
                    .size(60.dp)
                    .padding(4.dp)
                    .clip(CircleShape)
            )
            Column(modifier = Modifier.padding(8.dp)) {
                Text(
                    text = "${user.firstname} ${user.lastname}",
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.Black
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.Black
                )
            }
        }
    }
    HorizontalDivider()
}

package com.example.chatapplication.ui.screen.group.add

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.model.User
import com.example.chatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class GroupAddViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _groupName = MutableStateFlow("")
    val groupName: StateFlow<String> = _groupName

    private val _userList = MutableStateFlow<List<User>>(emptyList())
    val userList: StateFlow<List<User>> = _userList

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading


    fun onGroupNameChange(name: String) {
        _groupName.value = name
    }

    init {
        getUserList()
    }

    private fun getUserList() {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                _isLoading.value = true
                withContext(Dispatchers.IO) {
                    delay(1000)
                    try {
                        firestoreRepository.getUsersList { users ->
                            _userList.value = users
                        }
                    } catch (e: Exception) {
                        e.printStackTrace()
                    } finally {
                        _isLoading.value = false
                    }
                }
            }
        }
    }

    fun createGroup(name: String, selectedUser: List<String>) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                _isLoading.value = true
                try {
                    firestoreRepository.createGroup(name, selectedUser)
                } catch (e: Exception) {
                    e.printStackTrace()
                } finally {
                    _isLoading.value = false
                }
            }
        }
    }
}

---------------------------------------------------------------------
package com.example.chatapplication.ui.screen.group.chat

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.automirrored.filled.Send
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.AsyncImagePainter
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.GROUP_DETAIL_SCREEN
import com.example.chatapplication.model.Message
import com.example.chatapplication.ui.theme.CustomGreen
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupChatScreen(innerNavController: NavHostController, groupId: String) {
    val groupChatViewModel = hiltViewModel<GroupChatViewModel>()
    val messages by groupChatViewModel.messages.collectAsState()
    val textMessage by groupChatViewModel.newMessage.collectAsState()
    val groupName by groupChatViewModel.groupName.collectAsState()

    LaunchedEffect(Unit) {
        groupChatViewModel.init(groupId)
    }

    val launcher =
        rememberLauncherForActivityResult(contract = ActivityResultContracts.GetContent()) { uri: Uri? ->
            uri?.let { groupChatViewModel.uploadImageAndSendMessage(it) }
            groupChatViewModel.onImageUriChange(uri)
        }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Row(verticalAlignment = Alignment.CenterVertically) {
                        Image(
                            painter = painterResource(id = R.drawable.account),
                            contentDescription = "",
                            modifier = Modifier
                                .size(60.dp)
                                .padding(4.dp)
                                .border(1.dp, Color.LightGray, CircleShape)
                        )
                        Text(
                            text = groupName,
                            color = Color.White,
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(8.dp)
                        )
                    }
                },
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { innerNavController.popBackStack() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(CustomGreen),
                modifier = Modifier.clickable {
                    innerNavController.navigate("$GROUP_DETAIL_SCREEN/$groupId")
                }
            )
        },
        bottomBar = {
            BottomAppBar(containerColor = Color.LightGray) {
                Row(verticalAlignment = Alignment.CenterVertically) {
                    TextField(
                        value = textMessage,
                        onValueChange = { groupChatViewModel.updateMessage(it) },
                        maxLines = 4,
                        placeholder = { Text(text = "Type your message...") },
                        modifier = Modifier
                            .weight(1f)
                            .padding(8.dp)
                    )
                    IconButton(onClick = { launcher.launch("image/*") }) {
                        Icon(painter = painterResource(id = R.drawable.media), contentDescription = null)
                    }
                    IconButton(onClick = { groupChatViewModel.sendMessage(groupId) }) {
                        Icon(imageVector = Icons.AutoMirrored.Filled.Send, contentDescription = null)
                    }
                }
            }
        },
        content = { paddingValues ->
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            ) {
                items(messages) { message ->
                    GroupChatCard(viewModel = groupChatViewModel, message = message)
                }
            }
        }
    )
}

@Composable
fun GroupChatCard(viewModel: GroupChatViewModel, message: Message) {
    val senderName = viewModel.getSenderName(message.senderId)
    val isCurrentUser = message.senderId == FirebaseAuth.getInstance().currentUser?.uid
    val backgroundColor = if (isCurrentUser) CustomGreen else Color.Gray

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = if (isCurrentUser) Arrangement.End else Arrangement.Start,
    ) {
        Card(
            colors = CardDefaults.cardColors(backgroundColor),
            modifier = Modifier
                .padding(horizontal = 8.dp)
                .clip(MaterialTheme.shapes.medium)
        ) {
            Column {
                Text(
                    text = senderName,
                    color = Color.White,
                    style = MaterialTheme.typography.labelMedium,
                    modifier = Modifier
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                        .align(Alignment.Start)
                )
                if (message.imageUrl?.isNotBlank() == true) {
                    val painter = rememberAsyncImagePainter(message.imageUrl)
                    Box {
                        if (painter.state is AsyncImagePainter.State.Loading) {
                            CircularProgressIndicator(
                                color = Color.White,
                                modifier = Modifier
                                    .padding(16.dp)
                                    .align(Alignment.Center)
                            )
                        }
                        Image(
                            painter = painter,
                            contentDescription = null,
                            contentScale = ContentScale.FillBounds,
                            modifier = Modifier.size(120.dp).padding(4.dp)
                        )
                    }
                }
                if (message.message.isNotBlank()) {
                    Text(
                        text = message.message,
                        color = Color.White,
                        style = MaterialTheme.typography.bodyLarge,
                        modifier = Modifier.padding(start = 8.dp, end = 8.dp, bottom = 8.dp, top = 4.dp)
                    )
                }
            }
        }
    }
}

@Preview
@Composable
fun GroupChatScreenPreview() {
    GroupChatScreen(NavHostController(LocalContext.current), "1")
}

package com.example.chatapplication.ui.screen.group.chat

import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.model.Message
import com.example.chatapplication.repository.firestore.FirestoreRepository
import com.google.firebase.auth.FirebaseAuth
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class GroupChatViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository,
) : ViewModel() {
    private val _messages = MutableStateFlow<List<Message>>(emptyList())
    val messages: StateFlow<List<Message>> = _messages

    private val _newMessage = MutableStateFlow("")
    val newMessage: StateFlow<String> = _newMessage

    private val _imageUri = MutableStateFlow<Uri?>(null)

    private lateinit var groupId: String
    private val _userNameMap = MutableStateFlow<Map<String, String>>(emptyMap())

    private val _groupName = MutableStateFlow("")
    val groupName: StateFlow<String> = _groupName

    fun init(groupId: String) {
        this.groupId = groupId
        loadMessages(groupId)
        loadGroupDetails(groupId)
    }

    private fun loadMessages(groupId: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.getGroupMessages(groupId) { messages ->
                    _messages.value = messages
                    fetchUserNames(messages)
                }
            }
        }
    }

    fun sendMessage(groupId: String) {
        val senderId = FirebaseAuth.getInstance().currentUser?.uid ?: ""
        val content = _newMessage.value.trim()

        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                if (content.isNotBlank()) {
                    firestoreRepository.sendMessageToGroup(groupId, senderId, content, null)
                    _newMessage.value = ""
                }
            }
        }
    }

    fun getSenderName(senderId: String): String {
        return _userNameMap.value[senderId] ?: senderId
    }

    private fun loadGroupDetails(groupId: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.getGroupDetails(groupId) { group ->
                    if (group != null) {
                        _groupName.value = group.name
                    }
                }
            }
        }
    }

    private fun fetchUserNames(messages: List<Message>) {
        val userIds = messages.map { it.senderId }.distinct()
        userIds.forEach { userId ->
            firestoreRepository.getUserDetails(userId) { user ->
                val updatedMap = _userNameMap.value.toMutableMap()
                updatedMap[userId] = "${user.firstname} ${user.lastname}"
                _userNameMap.value = updatedMap
            }
        }
    }

    fun uploadImageAndSendMessage(uri: Uri) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.uploadImage(uri) { imageUrl ->
                    sendImageMessage(groupId, imageUrl)
                }
            }
        }
    }

    private fun sendImageMessage(groupId: String, imageUrl: String) {
        val senderId = FirebaseAuth.getInstance().currentUser?.uid ?: ""
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.sendMessageToGroup(groupId, senderId, "", imageUrl)
            }
        }
    }

    fun onImageUriChange(uri: Uri?) {
        _imageUri.value = uri
    }

    fun updateMessage(message: String) {
        _newMessage.value = message
    }
}
---------------------------------------------------------------------------
package com.example.chatapplication.ui.screen.group.detail

import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.ui.theme.CustomGreen
import com.example.chatapplication.ui.theme.DarkestGreen

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun GroupDetailScreen(
    innerNavController: NavHostController,
    groupId: String
) {
    val viewModel = hiltViewModel<GroupDetailViewModel>()
    val group by viewModel.group.collectAsState()
    val isShowing by viewModel.show.collectAsState()
    val context = LocalContext.current
    val userDetails by viewModel.userDetails.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.loadGroupDetails(groupId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(group?.name ?: "", color = Color.White) },
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { innerNavController.popBackStack() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(CustomGreen)
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            item {
                Image(
                    painter = painterResource(id = R.drawable.account),
                    contentDescription = "",
                    modifier = Modifier
                        .padding(8.dp)
                        .size(120.dp)
                        .clip(CircleShape)
                )
                Text(
                    text = group?.name ?: "",
                    modifier = Modifier.padding(8.dp),
                    style = MaterialTheme.typography.titleLarge
                )
                HorizontalDivider(modifier = Modifier.padding(horizontal = 16.dp))

                // Display user details
                group?.users?.forEach { userId ->
                    val user = userDetails[userId]
                    Card(
                        colors = CardDefaults.cardColors(Color.White),
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 4.dp, horizontal = 8.dp)
                            .clip(TextFieldDefaults.shape)
                    ) {
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Image(
                                painter = if (user?.image?.isNotEmpty() == true) {
                                    rememberAsyncImagePainter(model = user.image, placeholder = painterResource(
                                        id = R.drawable.account
                                    )) // Replace with user image resource
                                } else {
                                    painterResource(id = R.drawable.account)
                                },
                                contentDescription = "",
                                modifier = Modifier
                                    .size(60.dp)
                                    .padding(8.dp)
                            )
                            Text(
                                text = "${user?.firstname} ${user?.lastname}",
                                modifier = Modifier
                                    .weight(1f)
                                    .padding(horizontal = 8.dp),
                                color = Color.Black,
                                style = MaterialTheme.typography.titleMedium
                            )
                            if (userId == group?.createdBy) {
                                Text(
                                    text = stringResource(R.string.admin),
                                    color = DarkestGreen,
                                    style = MaterialTheme.typography.titleMedium,
                                    modifier = Modifier.padding(16.dp)
                                )
                            }
                        }
                        HorizontalDivider(modifier = Modifier.padding(horizontal = 8.dp))
                    }
                }
            }
            item {
                Button(
                    onClick = {
                        viewModel.showExitDialog(true)
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    colors = ButtonDefaults.buttonColors(Color.Red),
                ) {
                    Text(
                        text = stringResource(R.string.btn_exit),
                        color = Color.White,
                        modifier = Modifier.padding(horizontal = 16.dp)
                    )
                    Icon(
                        painter = painterResource(id = R.drawable.logout),
                        contentDescription = "",
                        tint = Color.White
                    )
                }
            }
        }
    }

    if (isShowing) {
        AlertDialog(
            containerColor = CustomGreen,
            onDismissRequest = { viewModel.showExitDialog(true) },
            confirmButton = {
                TextButton(
                    onClick = {
                        viewModel.deleteGroup(groupId, context, innerNavController)
                    }
                ) {
                    Text(
                        text = stringResource(id = R.string.exit),
                        color = Color.White,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            },
            dismissButton = {
                TextButton(onClick = { viewModel.showExitDialog(false) }) {
                    Text(
                        text = stringResource(R.string.btn_cancel),
                        color = Color.White,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            },
            title = {
                Text(
                    text = stringResource(R.string.yes),
                    color = Color.White,
                    style = MaterialTheme.typography.titleLarge
                )
            },
            text = {
                Text(
                    text = stringResource(R.string.exit_group_msg),
                    color = Color.White,
                    style = MaterialTheme.typography.bodyLarge
                )
            }
        )
    }
}

package com.example.chatapplication.ui.screen.group.detail

import android.content.Context
import android.widget.Toast
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.navigation.NavHostController
import com.example.chatapplication.constants.CONSTANTS.GROUP_SCREEN
import com.example.chatapplication.model.Group
import com.example.chatapplication.model.User
import com.example.chatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class GroupDetailViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository,
) : ViewModel() {

    private val _group = MutableStateFlow<Group?>(null)
    val group: StateFlow<Group?> = _group

    private val _show = MutableStateFlow(false)
    val show: StateFlow<Boolean> = _show

    private val _userDetails = MutableStateFlow<Map<String, User>>(emptyMap())
    val userDetails: StateFlow<Map<String, User>> = _userDetails

    fun showExitDialog(status: Boolean) {
        _show.value = status
    }

    fun loadGroupDetails(groupId: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                firestoreRepository.getGroupDetails(groupId) { group ->
                    _group.value = group

                    group?.users?.forEach { userId ->
                        if (userId != null) {
                            firestoreRepository.getUserDetails(userId) { user ->
                                // Update user details map
                                val updatedMap = _userDetails.value.toMutableMap()
                                updatedMap[user.id] = user
                                _userDetails.value = updatedMap
                            }
                        }
                    }
                }
            }
        }
    }

    fun deleteGroup(groupId: String, context: Context, innerNavController: NavHostController) {
        viewModelScope.launch {
            firestoreRepository.exitGroup(groupId) { success ->
                if (success) {
                    Toast.makeText(context, "exited successfully", Toast.LENGTH_SHORT).show()
                    innerNavController.navigate(GROUP_SCREEN)
                } else {
                    Toast.makeText(context, "Failed to exit group", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
}

package com.example.chatapplication.ui.screen.group.list

import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.GROUP_CHAT_SCREEN
import com.example.chatapplication.model.Group
import com.example.chatapplication.ui.theme.CustomGreen

@Composable
fun GroupListScreen(innerNavController: NavHostController)  {

    val groupViewModel = hiltViewModel<GroupListScreenViewModel>()
    val groupList by groupViewModel.groupList.collectAsState()

    LazyColumn(modifier = Modifier.fillMaxSize()) {
        item {
            Text(
                text = stringResource(R.string.groups_title),
                color = CustomGreen,
                fontWeight = FontWeight.W600,
                style = MaterialTheme.typography.headlineMedium,
                modifier = Modifier.padding(16.dp)
            )
            HorizontalDivider(modifier = Modifier.padding(horizontal = 8.dp))
        }
        item {
            if (groupList.isEmpty()) {
                Column(
                    modifier = Modifier.fillMaxSize(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(text = stringResource(R.string.no_groups_available), modifier = Modifier.padding(16.dp))
                }
            }
        }
        items(groupList) { group ->
            GroupChatListCard(group, innerNavController)
        }
    }
}

@Composable
fun GroupChatListCard(group: Group, innerNavController: NavHostController) {
    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .clickable {
                innerNavController.navigate("$GROUP_CHAT_SCREEN/${group.id}")
            }
    ) {
        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(4.dp)) {
            Image(
                painter = painterResource(id = R.drawable.account),
                contentDescription = "",
                modifier = Modifier
                    .size(60.dp)
                    .padding(4.dp)
                    .align(Alignment.CenterVertically)
            )
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(4.dp)
            ) {
                Text(
                    text = group.name,
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.Black,
                    modifier = Modifier.padding(vertical = 4.dp)
                )
                Text(
                    text = "lastMessage",
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.DarkGray
                )
            }
            Text(
                text = "00:00",
                style = MaterialTheme.typography.bodyMedium,
                color = Color.Gray,
                modifier = Modifier
                    .align(Alignment.Bottom)
                    .padding(horizontal = 4.dp)
            )
        }
        HorizontalDivider(modifier = Modifier.padding(horizontal = 8.dp))
    }
}

@Preview
@Composable
fun GroupScreenPreview() {
    GroupListScreen(NavHostController(LocalContext.current))
}
package com.example.chatapplication.ui.screen.group.list

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.model.Group
import com.example.chatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class GroupListScreenViewModel  @Inject constructor(
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _groupList = MutableStateFlow<List<Group>>(emptyList())
    val groupList: StateFlow<List<Group>> = _groupList

    init {
        getGroupList()
    }

    private fun getGroupList() {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                try {
                    firestoreRepository.getGroups { groupList ->
                        Log.d("GROUP_LIST", "getGroupList: $groupList ")
                        _groupList.value = groupList
                    }
                } catch (e: Exception) {
                    Log.d("GROUP_LIST", "Error fetching groupList :- ${e.message}")
                }
            }
        }
    }
}
------------------------------------------------------
package com.example.chatapplication.ui.screen.home

import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.CHAT_SCREEN
import com.example.chatapplication.constants.CONSTANTS.USERS_LIST_SCREEN
import com.example.chatapplication.model.ChatRoom
import com.example.chatapplication.model.User
import com.example.chatapplication.ui.theme.CustomGreen
import com.google.firebase.auth.FirebaseAuth

@Composable
fun HomeScreen(navController: NavHostController) {

    val homeViewModel = hiltViewModel<HomeViewModel>()
    val chatRoomList by homeViewModel.chatRoomList.collectAsState()
    val userDetails by homeViewModel.userDetails.collectAsState()
    val unreadMessageCounts by homeViewModel.unreadMessageCounts.collectAsState()

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(
                onClick = { navController.navigate(USERS_LIST_SCREEN) },
                containerColor = CustomGreen
            ) {
                Image(painter = painterResource(id = R.drawable.message), contentDescription = "")
            }
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize()
        ) {
            item {
                Text(
                    text = stringResource(R.string.chats_title),
                    color = CustomGreen,
                    fontWeight = FontWeight.W600,
                    style = MaterialTheme.typography.headlineMedium,
                    modifier = Modifier.padding(16.dp)
                )
                HorizontalDivider(modifier = Modifier.padding(horizontal = 8.dp))
            }
            item {
                if (chatRoomList.isEmpty()) {
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = stringResource(R.string.no_chats_available),
                            modifier = Modifier.padding(16.dp)
                        )
                    }
                }
            }
            items(chatRoomList) { chatRoom ->
                val otherUserId =
                    chatRoom.participants.first { it != FirebaseAuth.getInstance().currentUser?.uid }
                val user = userDetails[otherUserId]
                val unreadCount = unreadMessageCounts[chatRoom.chatroomId] ?: 0
                if (user != null) {
                    UserChatList(chatRoom, user, unreadCount, navController)
                }
            }
        }
    }
}

@Composable
fun UserChatList(
    chatRoom: ChatRoom,
    user: User,
    unreadCount: Int,
    navController: NavHostController,
) {

    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .clickable {
                navController.navigate("$CHAT_SCREEN/${user.id}")
            }
    ) {
        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(4.dp)) {
            Image(
                painter = rememberAsyncImagePainter(
                    model = user.image,
                    placeholder = painterResource(id = R.drawable.account)
                ),
                contentDescription = "",
                modifier = Modifier
                    .size(60.dp)
                    .padding(4.dp)
                    .align(Alignment.CenterVertically)
            )
            Column(
                modifier = Modifier
                    .weight(1f)
                    .padding(4.dp)
            ) {
                Text(
                    text = "${user.firstname} ${user.lastname}",
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.Black,
                    modifier = Modifier.padding(vertical = 4.dp)
                )
                Text(
                    text = chatRoom.lastMessage,
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.DarkGray
                )
                if (unreadCount > 0) {
                    Text(
                        text = stringResource(R.string.unread_message_count, unreadCount),
                        style = MaterialTheme.typography.bodySmall,
                        color = Color.Red,
                        modifier = Modifier.padding(vertical = 4.dp)
                    )
                }
            }
        }
        HorizontalDivider(modifier = Modifier.padding(horizontal = 8.dp))
    }
}

@Preview
@Composable
fun HomeScreenPreview() {
    HomeScreen(NavHostController(LocalContext.current))
}

package com.example.chatapplication.ui.screen.home

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.model.ChatRoom
import com.example.chatapplication.model.User
import com.example.chatapplication.repository.firestore.FirestoreRepository
import com.google.firebase.auth.FirebaseAuth
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class HomeViewModel @Inject constructor(
    val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _chatRoomList = MutableStateFlow<List<ChatRoom>>(emptyList())
    val chatRoomList: StateFlow<List<ChatRoom>> = _chatRoomList

    private val _userDetails = MutableStateFlow<Map<String, User>>(emptyMap())
    val userDetails: StateFlow<Map<String, User>> = _userDetails

    init {
        getChattedUserList()
    }

    private fun getChattedUserList() {
        viewModelScope.launch {
            firestoreRepository.getRoomChats().collect { chatRooms ->
                _chatRoomList.value = chatRooms
                chatRooms.forEach { chatRoom ->
                    val otherUserId = chatRoom.participants.first { it != FirebaseAuth.getInstance().currentUser?.uid }
                    fetchUserDetails(otherUserId)
                }
            }
        }
    }

    private fun fetchUserDetails(userId: String) {
        firestoreRepository.getUserDetails(userId) { user ->
            _userDetails.update { it + (userId to user) }
        }
    }


    private val _unreadMessageCounts = MutableStateFlow<Map<String, Int>>(emptyMap())
    val unreadMessageCounts: StateFlow<Map<String, Int>> = _unreadMessageCounts

    private fun fetchUnreadMessageCount(chatRoomId: String) {
        val userId = FirebaseAuth.getInstance().currentUser?.uid ?: return
        firestoreRepository.getUnreadMessageCount(chatRoomId, userId) { unreadCount ->
            _unreadMessageCounts.update { it + (chatRoomId to unreadCount) }
        }
    }
}

package com.example.chatapplication.ui.screen.settings

import androidx.compose.foundation.Image
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.SwitchDefaults
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.LOGIN_SCREEN
import com.example.chatapplication.ui.theme.CustomGreen

@Composable
fun SettingsScreen(
    navController: NavHostController,
    darkTheme: Boolean,
    darkThemeChange: () -> Unit,
) {
    val settingsViewModel = hiltViewModel<SettingsViewModel>()
    var notification by rememberSaveable { mutableStateOf(true) }
    val currentUser by settingsViewModel.currentUser.observeAsState()
    val showDialog by settingsViewModel.showDialog.collectAsState()
    val userImageUrl by settingsViewModel.userImageUrl.collectAsState()

    LazyColumn(
        modifier = Modifier
            .fillMaxSize()
            .padding(8.dp)
    ) {
        item {
            ProfileCard(
                userName = currentUser?.displayName ?: stringResource(R.string.user_name),
                userEmail = currentUser?.email ?: stringResource(R.string.email),
                userImageUrl = userImageUrl
            )
            Spacer(modifier = Modifier.height(24.dp))
            Text(
                text = stringResource(R.string.settings),
                modifier = Modifier.padding(8.dp),
                style = MaterialTheme.typography.titleLarge
            )
            AppSettings(image = R.drawable.key, title = stringResource(R.string.account))
            AppSettings(image = R.drawable.chat, title = stringResource(R.string.chats))
            AppSettings(image = R.drawable.payment, title = stringResource(R.string.payment))
            HorizontalDivider()
            Switch(
                image = R.drawable.notification,
                title = stringResource(R.string.notification),
                checked = notification
            ) {
                notification = !notification
            }
            HorizontalDivider()
            Switch(
                image = R.drawable.night_mode,
                title = stringResource(R.string.night_mode),
                checked = darkTheme
            ) {
                darkThemeChange()
            }
            HorizontalDivider()
            AppSettings(
                image = R.drawable.logout,
                title = stringResource(R.string.btn_logout),
                modifier = Modifier.clickable {
                    settingsViewModel.onDialogStatusChange(true)
                }
            )
        }
    }
    if (showDialog) {
        AlertDialog(
            containerColor = CustomGreen,
            onDismissRequest = { settingsViewModel.onDialogStatusChange(false) },
            confirmButton = {
                TextButton(
                    onClick = {
                        settingsViewModel.logOut()
                        navController.navigate(LOGIN_SCREEN) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                ) {
                    Text(
                        text = stringResource(id = R.string.btn_logout),
                        color = Color.White,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            },
            dismissButton = {
                TextButton(onClick = { settingsViewModel.onDialogStatusChange(false) }) {
                    Text(
                        text = stringResource(R.string.btn_cancel),
                        color = Color.White,
                        style = MaterialTheme.typography.titleMedium
                    )
                }
            },
            title = {
                Text(
                    text = stringResource(R.string.logout),
                    color = Color.White,
                    style = MaterialTheme.typography.titleLarge
                )
            },
            text = {
                Text(
                    text = stringResource(R.string.logout_dialog_msg),
                    color = Color.White,
                    style = MaterialTheme.typography.bodyLarge
                )
            }
        )
    }
}

@Composable
fun AppSettings(image: Int, title: String, modifier: Modifier = Modifier) {
    HorizontalDivider()
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Image(painter = painterResource(id = image), contentDescription = "")
        Text(
            text = title,
            modifier = Modifier.padding(12.dp),
            style = MaterialTheme.typography.titleMedium
        )
    }
}

@Composable
fun Switch(image: Int, title: String, checked: Boolean, onCheckedChange: ((Boolean) -> Unit)?) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 12.dp, horizontal = 8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Image(
            painter = painterResource(id = image),
            contentDescription = "",
            modifier = Modifier.padding(end = 12.dp)
        )
        Text(
            text = title,
            style = MaterialTheme.typography.titleMedium,
            modifier = Modifier.weight(1f)
        )
        androidx.compose.material3.Switch(
            checked = checked,
            onCheckedChange = onCheckedChange,
            colors = SwitchDefaults.colors(
                checkedTrackColor = CustomGreen,
                uncheckedTrackColor = Color.LightGray,
                checkedThumbColor = Color.White
            ),
            modifier = Modifier.padding(horizontal = 8.dp)
        )
    }
}

@Composable
fun ProfileCard(userName: String, userEmail: String, userImageUrl: String?) {
    Card(
        colors = CardDefaults.cardColors(CustomGreen),
        modifier = Modifier
            .fillMaxWidth()
            .padding(8.dp)
    ) {
        Row {
            if (userImageUrl != null) {
                Image(
                    painter = rememberAsyncImagePainter(userImageUrl, placeholder = painterResource(R.drawable.account)),
                    contentDescription = "",
                    contentScale = ContentScale.Crop,
                    modifier = Modifier
                        .size(120.dp)
                        .padding(8.dp)
                        .clip(CircleShape)
                        .border(1.dp, Color.DarkGray, CircleShape)
                )
            } else {
                Image(
                    painter = painterResource(id = R.drawable.account),
                    contentDescription = "",
                    modifier = Modifier
                        .size(120.dp)
                        .padding(8.dp)
                        .border(1.dp, Color.DarkGray, CircleShape)
                )
            }
            Column(
                modifier = Modifier
                    .padding(12.dp)
                    .align(Alignment.CenterVertically),
                verticalArrangement = Arrangement.Center
            ) {
                Text(
                    text = userName,
                    modifier = Modifier.padding(4.dp),
                    color = Color.White,
                    style = MaterialTheme.typography.titleLarge
                )
                Text(
                    text = userEmail,
                    modifier = Modifier.padding(4.dp),
                    color = Color.White,
                    style = MaterialTheme.typography.titleMedium
                )
            }
        }
    }
}

@Preview
@Composable
fun SettingsScreenPreview() {
    SettingsScreen(navController = NavHostController(LocalContext.current), false) { }
}
package com.example.chatapplication.ui.screen.settings

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import com.example.chatapplication.repository.auth.FirebaseAuthRepository
import com.example.chatapplication.repository.firestore.FirestoreRepository
import com.google.firebase.auth.FirebaseUser
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import javax.inject.Inject

@HiltViewModel
class SettingsViewModel @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _currentUser = MutableLiveData<FirebaseUser?>()
    val currentUser: LiveData<FirebaseUser?> = _currentUser

    private val _showDialog = MutableStateFlow(false)
    val showDialog: StateFlow<Boolean> = _showDialog

    private val _userImageUrl = MutableStateFlow<String?>(null)
    val userImageUrl: StateFlow<String?> = _userImageUrl

    init {
        _currentUser.value = authRepository.getCurrentUser()
        _currentUser.value?.let { user ->
            fetchUserImageUrl(user.uid)
        }
    }

    private fun fetchUserImageUrl(userId: String) {
        firestoreRepository.getUserDetails(userId) { user ->
            _userImageUrl.value = user.image
        }
    }

    fun onDialogStatusChange(status: Boolean) {
        _showDialog.value = status
    }

    fun logOut() {
        authRepository.logOut()
        _currentUser.value = null
    }
}

package com.example.chatapplication.ui.screen.signup

import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.Lock
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.LOGIN_SCREEN
import com.example.chatapplication.constants.CONSTANTS.MAIN_SCREEN
import com.example.chatapplication.ui.components.InputTextField
import com.example.chatapplication.ui.components.LoadingDialog
import com.example.chatapplication.ui.theme.CustomGreen

@Composable
fun SignUpScreen(navController: NavHostController) {

    val context = LocalContext.current
    val signUpViewModel = hiltViewModel<SignUpViewModel>()
    val profileImageUri by signUpViewModel.profileImageUri.collectAsState()
    val firstName by signUpViewModel.firstName.collectAsState()
    val lastName by signUpViewModel.lastName.collectAsState()
    val email by signUpViewModel.email.collectAsState()
    val password by signUpViewModel.password.collectAsState()
    val confirmPassword by signUpViewModel.cPassword.collectAsState()
    val passwordVisible by signUpViewModel.passwordVisible.collectAsState()
    val isLoading by signUpViewModel.isLoading.collectAsState()

    val launcher =
        rememberLauncherForActivityResult(contract = ActivityResultContracts.GetContent()) { uri ->
            if (uri != null) {
                signUpViewModel.onProfileImageUriChange(uri)
            }
        }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            painter = painterResource(id = R.drawable.bg),
            contentDescription = "",
            contentScale = ContentScale.FillBounds,
            modifier = Modifier
                .fillMaxSize()
        )
        LazyColumn(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            item {
                Text(
                    text = stringResource(R.string.talk_hub),
                    fontFamily = FontFamily.Serif,
                    style = MaterialTheme.typography.displaySmall,
                    textAlign = TextAlign.Center,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                )
                Image(
                    painter = if (profileImageUri != null) rememberAsyncImagePainter(profileImageUri) else painterResource(
                        id = R.drawable.account
                    ),
                    contentDescription = "",
                    contentScale = ContentScale.FillBounds,
                    modifier = Modifier
                        .padding(16.dp)
                        .clip(CircleShape)
                        .size(160.dp)
                        .clickable {
                            launcher.launch("image/*")
                        }
                )
                InputTextField(
                    value = firstName,
                    onValueChange = { signUpViewModel.onFirstNameChange(it) },
                    label = { Text(text = stringResource(R.string.first_name)) },
                )
                InputTextField(
                    value = lastName,
                    onValueChange = { signUpViewModel.onLastNameChange(it) },
                    label = { Text(text = stringResource(R.string.last_name)) },
                )
                InputTextField(
                    value = email,
                    onValueChange = { signUpViewModel.onEmailChange(it) },
                    label = { Text(text = stringResource(R.string.email_address)) },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email)
                        .copy(imeAction = ImeAction.Next),
                    leadingIcon = {
                        Icon(imageVector = Icons.Default.Email, contentDescription = "")
                    }
                )
                InputTextField(
                    value = password,
                    onValueChange = { signUpViewModel.onPasswordChange(it) },
                    label = { Text(text = stringResource(R.string.password)) },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
                        .copy(imeAction = ImeAction.Next),
                    leadingIcon = {
                        Icon(imageVector = Icons.Default.Lock, contentDescription = "")
                    },
                    trailingIcon = {
                        val image = if (passwordVisible) R.drawable.hidden else R.drawable.show
                        IconButton(onClick = { signUpViewModel.onVisibilityChange(!passwordVisible) }) {
                            Image(painter = painterResource(id = image), "")
                        }
                    },
                    visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation()
                )
                InputTextField(
                    value = confirmPassword,
                    onValueChange = { signUpViewModel.onConfirmPasswordChange(it) },
                    label = { Text(text = stringResource(R.string.confirm_password)) },
                    leadingIcon = {
                        Icon(
                            imageVector = Icons.Default.Lock,
                            contentDescription = ""
                        )
                    },
                    trailingIcon = {
                        val image = if (passwordVisible) R.drawable.hidden else R.drawable.show
                        IconButton(onClick = { signUpViewModel.onVisibilityChange(!passwordVisible) }) {
                            Image(painter = painterResource(id = image), "")
                        }
                    },
                    visualTransformation = if (passwordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password).copy(
                        imeAction = ImeAction.Next
                    ),
                    supportingText = { Text(text = stringResource(R.string.password_hint), color = Color.DarkGray) },
                )
                Button(
                    colors = ButtonDefaults.buttonColors(CustomGreen),
                    onClick = {
                        signUpViewModel.uploadProfileImage(profileImageUri ?: Uri.EMPTY) { downloadUrl ->
                            if (downloadUrl != null) {
                                signUpViewModel.createAccount(
                                    imageUri = downloadUrl,
                                    firstName = firstName,
                                    lastName = lastName,
                                    email = email,
                                    password = password,
                                    confirmPassword = confirmPassword,
                                    context = context
                                ) { isValid ->
                                    if (isValid) {
                                        navController.navigate(MAIN_SCREEN) {
                                            popUpTo(LOGIN_SCREEN) { inclusive = true }
                                        }
                                    } else {
                                        Toast.makeText(
                                            context,
                                            context.getString(R.string.toast_email_exist),
                                            Toast.LENGTH_SHORT
                                        ).show()
                                    }
                                }
                            } else {
                                Toast.makeText(
                                    context,
                                    context.getString(R.string.toast_image_upload_failed),
                                    Toast.LENGTH_SHORT
                                ).show()
                            }
                        }
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    Text(text = stringResource(R.string.btn_signup))
                }


                Row(
                    horizontalArrangement = Arrangement.Center,
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier
                        .fillMaxWidth()
                        .align(Alignment.BottomCenter)
                        .padding(16.dp)
                ) {
                    Text(
                        text = stringResource(R.string.already_have_an_account),
                        fontWeight = FontWeight.W400,
                        style = MaterialTheme.typography.bodyLarge
                    )
                    TextButton(
                        onClick = {
                            navController.navigate(LOGIN_SCREEN)
                        }
                    ) {
                        Text(
                            text = stringResource(R.string.btn_login),
                            fontWeight = FontWeight.Bold,
                            color = CustomGreen,
                            style = MaterialTheme.typography.titleMedium
                        )
                    }
                }
            }
        }
        LoadingDialog(isLoading = isLoading)
    }
}
package com.example.chatapplication.ui.screen.signup

import android.content.Context
import android.net.Uri
import android.util.Patterns
import android.widget.Toast
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.R
import com.example.chatapplication.repository.auth.FirebaseAuthRepository
import com.example.chatapplication.repository.storage.StorageRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class SignUpViewModel @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val storageRepository: StorageRepository,
) : ViewModel() {

    private val fName = MutableStateFlow("")
    val firstName: StateFlow<String> = fName

    private val lName = MutableStateFlow("")
    val lastName: StateFlow<String> = lName

    private val _email = MutableStateFlow("")
    val email: StateFlow<String> = _email

    private val _password = MutableStateFlow("")
    val password: StateFlow<String> = _password

    private val _cPassword = MutableStateFlow("")
    val cPassword: StateFlow<String> = _cPassword

    private val _passwordVisible = MutableStateFlow(false)
    val passwordVisible: StateFlow<Boolean> = _passwordVisible

    private val _profileImageUri = MutableStateFlow<Uri?>(null)
    val profileImageUri: StateFlow<Uri?> = _profileImageUri

    fun onProfileImageUriChange(uri: Uri) {
        _profileImageUri.value = uri
    }

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    fun onFirstNameChange(name: String) {
        fName.value = name
    }

    fun onLastNameChange(surname: String) {
        lName.value = surname
    }

    fun onEmailChange(email: String) {
        _email.value = email
    }

    fun onPasswordChange(password: String) {
        _password.value = password
    }

    fun onConfirmPasswordChange(confirmPassword: String) {
        _cPassword.value = confirmPassword
    }

    fun onVisibilityChange(status: Boolean) {
        _passwordVisible.value = status
    }

    private fun isEmailValid(email: String): Boolean {
        return Patterns.EMAIL_ADDRESS.matcher(email).matches()
    }

    private fun isPasswordValid(password: String): Boolean {
        val passwordRegex = "^(?=.*[A-Z])(?=.*\\d)(?=.*[@\$!%*?&])[A-Za-z\\d@\$!%*?&]{8,}$"
        return password.matches(passwordRegex.toRegex())
    }

    fun createAccount(
        imageUri: String,
        firstName: String,
        lastName: String,
        email: String,
        password: String,
        confirmPassword: String,
        context: Context,
        onResult: (Boolean) -> Unit,
    ) {
        when {
            firstName.isEmpty() || lastName.isEmpty() -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_empty_fields), Toast.LENGTH_SHORT
                ).show()
            }

            email.isEmpty() || !isEmailValid(email) -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_email_error),
                    Toast.LENGTH_SHORT
                )
                    .show()
                onResult(false)
            }

            password.isEmpty() || !isPasswordValid(password) -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_valid_password), Toast.LENGTH_SHORT
                ).show()
                onResult(false)
            }

            confirmPassword.isEmpty() || confirmPassword != password -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_password_mismatch), Toast.LENGTH_SHORT
                ).show()
                onResult(false)
            }

            else -> {
                viewModelScope.launch {
                    withContext(Dispatchers.IO) {
                        _isLoading.value = true
                        authRepository.signUp(
                            fName = firstName,
                            lName = lastName,
                            email = email,
                            password = password,
                            imageUrl = imageUri
                        ) { success ->
                            _isLoading.value = false
                            onResult(success)
                        }
                    }
                }
            }
        }
    }

    fun uploadProfileImage(uri: Uri, onResult: (String?) -> Unit) {
        viewModelScope.launch {
            _isLoading.value = true
            withContext(Dispatchers.IO) {
                try {
                    val downloadUrl = storageRepository.uploadProfilePicture(uri)
                    withContext(Dispatchers.Main) {
                        onResult(downloadUrl)
                    }
                } catch (e: Exception) {
                    withContext(Dispatchers.Main) {
                        onResult(null)
                    }
                } finally {
                    _isLoading.value = false
                }
            }
        }
    }
}
package com.example.chatapplication.ui.screen.users

import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.CHAT_SCREEN
import com.example.chatapplication.constants.CONSTANTS.GROUP_ADD_SCREEN
import com.example.chatapplication.model.User
import com.example.chatapplication.ui.components.LoadingDialog
import com.example.chatapplication.ui.theme.CustomGreen
import com.google.firebase.auth.FirebaseAuth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun UserListScreen(navController: NavHostController) {

    val userListViewModel = hiltViewModel<UserListViewModel>()
    val userList by userListViewModel.userList.collectAsState()
    val isLoading by userListViewModel.isLoading.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                navigationIcon = {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { navController.popBackStack() }
                    )
                },
                title = {
                    Column(modifier = Modifier.padding(horizontal = 12.dp)) {
                        Text(
                            text = stringResource(R.string.contacts),
                            style = MaterialTheme.typography.titleLarge,
                            modifier = Modifier.padding(bottom = 4.dp),
                            color = Color.White,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = if (userList.size <= 1) stringResource(R.string.empty_contacts) else stringResource(
                                R.string.contact_list, userList.size - 1
                            ),
                            style = MaterialTheme.typography.titleSmall,
                            color = Color.White
                        )
                    }
                },
                actions = {
                    Icon(
                        imageVector = Icons.Default.Search,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier.padding(4.dp)
                    )
                    Icon(
                        imageVector = Icons.Default.Refresh,
                        contentDescription = "",
                        tint = Color.White,
                        modifier = Modifier
                            .padding(8.dp)
                            .clickable { userListViewModel.getUserList() }
                    )
                },
                colors = TopAppBarDefaults.topAppBarColors(CustomGreen)
            )
        }
    ) { paddingValues ->
        if (userList.size <= 1) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                Text(text = stringResource(R.string.no_users_available))
            }
        } else {
            LazyColumn(modifier = Modifier.padding(paddingValues)) {
                item {
                    GroupCard(navController)
                }
                items(userList) { user ->
                    val currentUser = FirebaseAuth.getInstance().currentUser
                    if (currentUser != null) {
                        if (user.email != currentUser.email) {
                            UserCard(user = user, navController = navController)
                        }
                    }
                }
            }
        }
        LoadingDialog(isLoading = isLoading)
    }
}

@Composable
fun UserCard(user: User, navController: NavHostController) {
    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 4.dp)
            .clickable {
                navController.navigate("$CHAT_SCREEN/${user.id}")
            }
    ) {
        Row(verticalAlignment = Alignment.CenterVertically, modifier = Modifier.padding(4.dp)) {
            Image(
                painter = if (user.image?.isNotEmpty() == true) rememberAsyncImagePainter(
                    model = user.image,
                    placeholder = painterResource(R.drawable.account)
                ) else painterResource(
                    id = R.drawable.account
                ),
                contentDescription = "",
                contentScale = ContentScale.Crop,
                modifier = Modifier
                    .size(60.dp)
                    .padding(4.dp)
                    .clip(CircleShape)
            )
            Column(modifier = Modifier.padding(8.dp)) {
                Text(
                    text = "${user.firstname} ${user.lastname}",
                    style = MaterialTheme.typography.titleMedium,
                    color = Color.Black
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.Black
                )
            }
        }
    }
    HorizontalDivider()
}

@Composable
fun GroupCard(navController: NavHostController) {
    Card(
        colors = CardDefaults.cardColors(Color.White),
        shape = TextFieldDefaults.shape,
        modifier = Modifier
            .fillMaxWidth()
            .padding(start = 4.dp, end = 4.dp, top = 4.dp)
            .clickable {
                navController.navigate(GROUP_ADD_SCREEN)
            }
    ) {
        Row(verticalAlignment = Alignment.CenterVertically) {
            Image(
                painter = painterResource(id = R.drawable.group),
                contentDescription = "",
                modifier = Modifier
                    .padding(12.dp)
                    .size(40.dp)
            )
            Text(
                text = stringResource(R.string.new_group),
                color = Color.Black,
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .weight(1f)
                    .padding(16.dp)
            )
        }
        HorizontalDivider()
    }
}

@Preview
@Composable
fun UserListScreenPreview() {
    UserListScreen(NavHostController(LocalContext.current))
}
package com.example.chatapplication.ui.screen.users

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.chatapplication.model.User
import com.example.chatapplication.repository.firestore.FirestoreRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class UserListViewModel @Inject constructor(
    private val firestoreRepository: FirestoreRepository
) : ViewModel() {

    private val _userList = MutableStateFlow<List<User>>(emptyList())
    val userList: StateFlow<List<User>> = _userList

    private val _isLoading = MutableStateFlow(false)
    val isLoading : StateFlow<Boolean> = _isLoading

    init {
        getUserList()
    }

    fun getUserList() {
        viewModelScope.launch {
            _isLoading.value = true
            withContext(Dispatchers.IO) {
                try {
                    firestoreRepository.getUsersList { users ->
                        _userList.value = users
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
                finally {
                    _isLoading.value = false
                }
            }
        }
    }
}

package com.example.chatapplication.ui.screen

import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.BottomAppBar
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import com.example.chatapplication.R
import com.example.chatapplication.constants.CONSTANTS.CHAT_SCREEN
import com.example.chatapplication.constants.CONSTANTS.GROUP_ADD_SCREEN
import com.example.chatapplication.constants.CONSTANTS.GROUP_CHAT_SCREEN
import com.example.chatapplication.constants.CONSTANTS.GROUP_DETAIL_SCREEN
import com.example.chatapplication.constants.CONSTANTS.GROUP_SCREEN
import com.example.chatapplication.constants.CONSTANTS.HOME_SCREEN
import com.example.chatapplication.constants.CONSTANTS.SETTINGS_SCREEN
import com.example.chatapplication.constants.CONSTANTS.USERS_LIST_SCREEN
import com.example.chatapplication.model.BottomNavItem
import com.example.chatapplication.ui.screen.chat.ChatScreen
import com.example.chatapplication.ui.screen.group.add.GroupAddScreen
import com.example.chatapplication.ui.screen.group.chat.GroupChatScreen
import com.example.chatapplication.ui.screen.group.detail.GroupDetailScreen
import com.example.chatapplication.ui.screen.group.list.GroupListScreen
import com.example.chatapplication.ui.screen.home.HomeScreen
import com.example.chatapplication.ui.screen.settings.SettingsScreen
import com.example.chatapplication.ui.screen.users.UserListScreen

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(navController: NavHostController, darkTheme: Boolean, darkThemeChange: () -> Unit) {

    val innerNavController = rememberNavController()
    val navBackStackEntry by innerNavController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route

    Surface {
        Scaffold(
            topBar = {
                if (currentRoute !in listOf(
                        USERS_LIST_SCREEN, "$CHAT_SCREEN/{userId}", GROUP_ADD_SCREEN,
                        "$GROUP_CHAT_SCREEN/{groupId}", "$GROUP_DETAIL_SCREEN/{groupId}"
                    )
                ) {
                    TopAppBar(
                        title = { Text(text = stringResource(id = R.string.talk_hub)) },
                        colors = TopAppBarDefaults.topAppBarColors(Color(0xFF2BCA8D))
                    )
                }
            },
            bottomBar = {
                if (currentRoute !in listOf(
                        USERS_LIST_SCREEN, "$CHAT_SCREEN/{userId}", GROUP_ADD_SCREEN,
                        "$GROUP_CHAT_SCREEN/{groupId}", "$GROUP_DETAIL_SCREEN/{groupId}"
                    )
                ) {
                    BottomNavigationBar(navController = innerNavController)
                }
            }
        ) { paddingValues ->
            NavHostContainer(
                navController = navController,
                innerNavController = innerNavController,
                padding = paddingValues,
                darkTheme = darkTheme,
                darkThemeChange = darkThemeChange
            )
        }
    }
}

@Composable
fun NavHostContainer(
    navController: NavHostController,
    innerNavController: NavHostController,
    padding: PaddingValues,
    darkTheme: Boolean,
    darkThemeChange: () -> Unit
) {
    NavHost(
        navController = innerNavController,
        startDestination = HOME_SCREEN,
        modifier = Modifier.padding(padding)
    ) {
        composable(HOME_SCREEN) {
            HomeScreen(innerNavController)
        }
        composable(GROUP_SCREEN) {
            GroupListScreen(innerNavController)
        }
        composable(SETTINGS_SCREEN) {
            SettingsScreen(navController, darkTheme, darkThemeChange)
        }
        composable(route = USERS_LIST_SCREEN) {
            UserListScreen(innerNavController)
        }
        composable("$CHAT_SCREEN/{userId}") { navBackStack ->
            val userId = navBackStack.arguments?.getString("userId")
            ChatScreen(innerNavController, userId)
        }
        composable(GROUP_ADD_SCREEN) {
            GroupAddScreen(innerNavController)
        }
        composable("$GROUP_DETAIL_SCREEN/{groupId}") { navBackStack ->
            val groupId = navBackStack.arguments?.getString("groupId")
            if (groupId != null) {
                GroupDetailScreen(innerNavController, groupId)
            }
        }

        composable("$GROUP_CHAT_SCREEN/{groupId}") { navBackStack ->
            val groupId = navBackStack.arguments?.getString("groupId")
            if (groupId != null) {
                GroupChatScreen(innerNavController, groupId)
            }
        }
    }
}

@Composable
fun BottomNavigationBar(navController: NavHostController) {
    val bottomNavItem = listOf(
        BottomNavItem(
            label = stringResource(R.string.groups),
            icon = R.drawable.group,
            route = GROUP_SCREEN
        ),
        BottomNavItem(
            label = stringResource(R.string.home),
            icon = R.drawable.home,
            route = HOME_SCREEN
        ),
        BottomNavItem(
            label = stringResource(id = R.string.settings),
            icon = R.drawable.settings,
            route = SETTINGS_SCREEN
        )
    )

    BottomAppBar(
        containerColor = Color.LightGray,
        contentColor = Color.White,
        tonalElevation = 8.dp
    ) {
        val navBackStackEntry by navController.currentBackStackEntryAsState()
        val currentRoute = navBackStackEntry?.destination?.route
        bottomNavItem.forEach { bottomNavItem ->
            NavigationBarItem(
                selected = currentRoute == bottomNavItem.route,
                onClick = { navController.navigate(bottomNavItem.route) },
                icon = {
                    Image(
                        painter = painterResource(id = bottomNavItem.icon),
                        contentDescription = bottomNavItem.label
                    )
                },
                label = { Text(text = bottomNavItem.label, color = Color.Black) },
                alwaysShowLabel = false
            )
        }
    }
}
