groupRef.update("unreadCount", count)

fun getUnreadMessageCount(groupId: String, callback: (Int) -> Unit) {
    val messagesRef = groupCollection.document(groupId).collection("messages")
    messagesRef.whereEqualTo("read", false).get()
        .addOnSuccessListener { result ->
            val unreadCount =
                result.documents.count { it.getString("senderId") != FirebaseAuth.getInstance().currentUser?.uid }
            Log.d("GroupRepository", "Unread messages in $groupId: $unreadCount")
            callback(unreadCount)
        }
        .addOnFailureListener {
            Log.e("GroupRepository", "Failed to get unread messages count: ${it.message}")
            callback(0)
        }
}


-----------------------------------------------------------------------------------------------

fun sendMessageToGroup(
    groupId: String,
    senderId: String,
    content: String,
    imageUrl: String? = null,
) {
    val time = System.currentTimeMillis()
    val messageData = hashMapOf(
        "senderId" to senderId,
        "content" to content,
        "imageUrl" to (imageUrl ?: ""),
        "timestamp" to time,
        "readBy" to emptyList<String>()
    )
    val groupRef = groupCollection.document(groupId)
    groupRef.collection("messages").add(messageData)
        .addOnSuccessListener { documentReference ->
            println("Message sent with ID: ${documentReference.id}")
            groupRef.update("lastMessage", content)
            groupRef.update("timestamp", time)

            groupRef.get().addOnSuccessListener { document ->
                val group = document.toObject(Group::class.java)
                val updatedUnreadCounts = group?.unreadCounts?.toMutableMap() ?: mutableMapOf()

                // Increment unread count for each user except the sender
                group?.users?.filter { it != senderId }?.forEach { userId ->
                    val count = updatedUnreadCounts[userId] ?: 0
                    updatedUnreadCounts[userId] = count + 1
                }

                groupRef.update("unreadCounts", updatedUnreadCounts)
                    .addOnSuccessListener {
                        println("Group's unread counts updated")
                    }
                    .addOnFailureListener { e ->
                        e.printStackTrace()
                    }
            }
        }
        .addOnFailureListener { e ->
            e.printStackTrace()
        }
}

fun markMessagesAsRead(groupId: String, onComplete: (Boolean) -> Unit) {
    val currentUser = FirebaseAuth.getInstance().currentUser
    val userId = currentUser?.uid ?: return

    val messagesRef = groupCollection.document(groupId).collection("messages")
    messagesRef.whereNotEqualTo("readBy", userId).get()
        .addOnSuccessListener { result ->
            val unreadMessages = result.documents.filter { it.getString("senderId") != userId }

            firestore.runTransaction { transaction ->
                for (message in unreadMessages) {
                    val readBy = message.get("readBy") as? List<String> ?: emptyList()
                    val updatedReadBy = readBy + userId
                    transaction.update(message.reference, "readBy", updatedReadBy)
                }

                val groupRef = groupCollection.document(groupId)
                val groupSnapshot = transaction.get(groupRef)
                val group = groupSnapshot.toObject(Group::class.java)
                val updatedUnreadCounts = group?.unreadCounts?.toMutableMap() ?: mutableMapOf()
                updatedUnreadCounts[userId] = 0
                transaction.update(groupRef, "unreadCounts", updatedUnreadCounts)
            }.addOnSuccessListener {
                Log.d("GroupRepository", "Marked messages as read in $groupId")
                onComplete(true)
            }.addOnFailureListener { e ->
                Log.e("GroupRepository", "Failed to mark messages as read: ${e.message}")
                onComplete(false)
            }
        }
        .addOnFailureListener { e ->
            Log.e("GroupRepository", "Failed to fetch unread messages: ${e.message}")
            onComplete(false)
        }
}

data class Group(
    var id: String = "",
    var name: String = "",
    var users: List<String> = emptyList(),
    var lastMessage: String = "",
    var createdBy: String = "",
    var timestamp: Long = 0L,
    var unreadCount: Int = 0,
    var unreadCounts: Map<String, Int> = emptyMap()
)

private fun fetchUnreadMessageCount(groupId: String) {
    viewModelScope.launch {
        groupRepository.getUnreadMessageCount(groupId) { unreadCount ->
            _groupList.update { groupList ->
                groupList.map { group ->
                    if (group.id == groupId) {
                        group.copy(unreadCount = unreadCount)
                    } else {
                        group
                    }
                }
            }
        }
    }
}
----------------------------------------------------------------------------------------------------------------------

@HiltViewModel
class SignUpViewModel @Inject constructor(
    private val authRepository: FirebaseAuthRepository,
    private val storageRepository: StorageRepository,
) : ViewModel() {

    private val fName = MutableStateFlow("")
    val firstName: StateFlow<String> = fName

    private val lName = MutableStateFlow("")
    val lastName: StateFlow<String> = lName

    private val _email = MutableStateFlow("")
    val email: StateFlow<String> = _email

    private val _password = MutableStateFlow("")
    val password: StateFlow<String> = _password

    private val _cPassword = MutableStateFlow("")
    val cPassword: StateFlow<String> = _cPassword

    private val _passwordVisible = MutableStateFlow(false)
    val passwordVisible: StateFlow<Boolean> = _passwordVisible

    private val _profileImageUri = MutableStateFlow<Uri?>(null)
    val profileImageUri: StateFlow<Uri?> = _profileImageUri

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    fun onProfileImageUriChange(uri: Uri) {
        _profileImageUri.value = uri
    }

    fun onFirstNameChange(name: String) {
        fName.value = name
    }

    fun onLastNameChange(surname: String) {
        lName.value = surname
    }

    fun onEmailChange(email: String) {
        _email.value = email
    }

    fun onPasswordChange(password: String) {
        _password.value = password
    }

    fun onConfirmPasswordChange(confirmPassword: String) {
        _cPassword.value = confirmPassword
    }

    fun onVisibilityChange(status: Boolean) {
        _passwordVisible.value = status
    }

    private fun isEmailValid(email: String): Boolean {
        return Patterns.EMAIL_ADDRESS.matcher(email).matches()
    }

    private fun isPasswordValid(password: String): Boolean {
        val passwordRegex = "^(?=.*[A-Z])(?=.*\\d)(?=.*[@\$!%*?&])[A-Za-z\\d@\$!%*?&]{8,}$"
        return password.matches(passwordRegex.toRegex())
    }

    fun createAccount(
        imageUri: String?,
        firstName: String,
        lastName: String,
        email: String,
        password: String,
        confirmPassword: String,
        context: Context,
        onResult: (Boolean) -> Unit,
    ) {
        when {
            imageUri?.isEmpty() == true -> {
                Toast.makeText(context,
                    context.getString(R.string.toast_image_select), Toast.LENGTH_SHORT).show()   
            }
            firstName.isEmpty() || lastName.isEmpty() -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_empty_fields), Toast.LENGTH_SHORT
                ).show()
            }

            email.isEmpty() || !isEmailValid(email) -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_email_error),
                    Toast.LENGTH_SHORT
                )
                    .show()
                onResult(false)
            }

            password.isEmpty() || !isPasswordValid(password) -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_valid_password), Toast.LENGTH_SHORT
                ).show()
                onResult(false)
            }

            confirmPassword.isEmpty() || confirmPassword != password -> {
                Toast.makeText(
                    context,
                    context.getString(R.string.toast_password_mismatch), Toast.LENGTH_SHORT
                ).show()
                onResult(false)
            }

            else -> {
                viewModelScope.launch {
                    _isLoading.value = true
                    withContext(Dispatchers.IO) {
                        authRepository.signUp(
                            fName = firstName,
                            lName = lastName,
                            email = email,
                            password = password,
                            imageUrl = imageUri ?: ""
                        ) { success ->
                            _isLoading.value = false
                            onResult(success)
                        }
                    }
                }
            }
        }
    }

    fun uploadProfileImage(uri: Uri, onResult: (String?) -> Unit) {
        viewModelScope.launch {
            _isLoading.value = true
            withContext(Dispatchers.IO) {
                try {
                    val downloadUrl = storageRepository.uploadProfilePicture(uri)
                    withContext(Dispatchers.Main) {
                        onResult(downloadUrl)
                    }
                } catch (e: Exception) {
                    withContext(Dispatchers.Main) {
                        onResult(null)
                    }
                } finally {
                    _isLoading.value = false
                }
            }
        }
    }
}
