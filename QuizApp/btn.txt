package com.example.contactkeeper.ui.screen.addScreen

import android.content.Context
import android.net.Uri
import android.util.Log
import android.util.Patterns
import android.widget.Toast
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.navigation.NavHostController
import com.example.contactkeeper.data.firestore.FireStoreService
import com.example.contactkeeper.data.model.Contact
import com.google.firebase.storage.FirebaseStorage
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.UUID

class AddContactViewModel : ViewModel() {

    private val _selectedContact = MutableStateFlow<Contact?>(null)
    val selectedContact: StateFlow<Contact?> = _selectedContact

    private val _name = MutableStateFlow("")
    val name: StateFlow<String> = _name

    private val _email = MutableStateFlow("")
    val email: StateFlow<String> = _email

    private val _phoneNo = MutableStateFlow(listOf(""))
    val phoneNo: StateFlow<List<String>> = _phoneNo

    private val _address = MutableStateFlow("")
    val address: StateFlow<String> = _address

    private val _imageUrl = MutableStateFlow("")
    val imageUrl: StateFlow<String> = _imageUrl

    private val _bloodGroup = MutableStateFlow("A+")
    val bloodGroup: StateFlow<String> = _bloodGroup

    private val _expanded: MutableLiveData<Boolean> = MutableLiveData(false)
    val expanded: LiveData<Boolean> = _expanded

    fun onNameChange(newName: String) {
        _name.value = newName
    }

    fun onEmailChange(newEmail: String) {
        _email.value = newEmail
    }

    fun onPhoneNumberChange(index: Int, newPhoneNo: String) {
        _phoneNo.value = _phoneNo.value.toMutableList().apply { this[index] = newPhoneNo }
    }

    fun addPhoneNumberField() {
        _phoneNo.value = _phoneNo.value.toMutableList().apply {
            add("")
        }
    }

    fun removePhoneNumberField() {
        _phoneNo.value = _phoneNo.value.toMutableList().apply {
            remove("")
        }
    }

    fun onAddressChange(newAddress: String) {
        _address.value = newAddress
    }

    fun onImageUrlChange(newImageUrl: String) {
        _imageUrl.value = newImageUrl
    }

    fun onBloodGroupChange(bloodGroup: String) {
        _bloodGroup.value = bloodGroup
    }

    fun onExpandedChange(expand: Boolean) {
        _expanded.value = expand
    }

    fun uploadImageToFirebase(
        uri: Uri,
        onSuccess: (String) -> Unit,
        onFailure: (Exception) -> Unit,
    ) {
        val storageRef = FirebaseStorage.getInstance().reference
        val imageRef = storageRef.child("images/${System.currentTimeMillis()}.jpg")
        val uploadTask = imageRef.putFile(uri)
        uploadTask.addOnSuccessListener {
            imageRef.downloadUrl.addOnSuccessListener { downloadUri ->
                onSuccess(downloadUri.toString())
            }.addOnFailureListener { exception ->
                onFailure(exception)
            }
        }.addOnFailureListener { exception ->
            onFailure(exception)
        }
    }


    private fun addContact(contact: Contact) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                uploadImageToFirebase(
                    Uri.parse(contact.profilePicture),
                    onSuccess = { imageUrl ->
                        contact.profilePicture = imageUrl
                        FireStoreService.addContact(contact)
                    },
                    onFailure = { exception ->
                        Log.d("EXCEPTION", "addContact: ${exception.message}")
                    }
                )
            }
        }
    }

    private fun updateContact(contact: Contact) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                if (contact.profilePicture.startsWith("content://")) {
                    uploadImageToFirebase(
                        Uri.parse(contact.profilePicture),
                        onSuccess = { imageUrl ->
                            contact.profilePicture = imageUrl
                            FireStoreService.updateContact(contact)
                        },
                        onFailure = { exception ->
                            Log.d("EXCEPTION", "updateContact: ${exception.message}")
                        }
                    )
                } else {
                    FireStoreService.updateContact(contact)
                }
            }
        }
    }

    fun fetchContactById(contactId: String) {
        viewModelScope.launch {
            withContext(Dispatchers.IO) {
                FireStoreService.getContacts().collect { list ->
                    val contact = list.find { it.id == contactId }
                    _selectedContact.value = contact
                }
            }
        }
    }

    fun setValues(contact: Contact) {
        _name.value = contact.name
        _email.value = contact.email
        _address.value = contact.address
        _imageUrl.value = contact.profilePicture
        _bloodGroup.value = contact.bloodGroup
        _phoneNo.value = contact.phoneNumber.toMutableList()
    }

    private fun isEmailValid(email: String): Boolean {
        return Patterns.EMAIL_ADDRESS.matcher(email).matches()
    }

    private fun isPhoneNumberValid(phone: String): Boolean {
        return phone.length == 10 && phone.all { it.isDigit() }
    }

    fun verifyDetails(
        contactID: String,
        name: String,
        email: String,
        phoneNumber: List<String>,
        profilePicture: String,
        bloodGroup: String,
        address: String,
        context: Context,
        navController: NavHostController,
    ): Boolean {
        return when {
            name.isEmpty() -> {
                Toast.makeText(context, "Please fill all details", Toast.LENGTH_SHORT).show()
                false
            }

            email.isEmpty() || !isEmailValid(email) -> {
                Toast.makeText(context, "Please enter valid email address", Toast.LENGTH_SHORT)
                    .show()
                false
            }

            (phoneNumber.isEmpty() || !isPhoneNumberValid(phoneNumber[0])) -> {
                Toast.makeText(context, "Please enter valid contact number", Toast.LENGTH_SHORT)
                    .show()
                false
            }

            (address.isEmpty()) -> {
                Toast.makeText(context, "Please fill all details", Toast.LENGTH_SHORT).show()
                false
            }

            else -> {
                val newContact = Contact(
                    id = if (contactID == "0") UUID.randomUUID().toString() else contactID,
                    name = name,
                    email = email,
                    phoneNumber = phoneNumber,
                    profilePicture = profilePicture,
                    bloodGroup = bloodGroup,
                    address = address
                )
                if (contactID == "0") {
                    addContact(newContact)
                } else {
                    updateContact(newContact)
                }
                navController.popBackStack()
                Toast.makeText(context, "Data Saved Successfully", Toast.LENGTH_SHORT)
                    .show()
                true
            }
        }
    }
}

package com.example.contactkeeper.ui.screen.addScreen

import android.net.Uri
import android.widget.Toast
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TextField
import androidx.compose.material3.TextFieldDefaults
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.TopAppBarDefaults
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.livedata.observeAsState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.navigation.NavHostController
import coil.compose.rememberAsyncImagePainter
import com.example.contactkeeper.R
import com.example.contactkeeper.ui.components.SwipeButton
import com.example.contactkeeper.ui.theme.CustomBlue
import com.example.contactkeeper.ui.theme.CustomGrey
import java.util.UUID

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddContactScreen(
    navController: NavHostController,
    viewModel: AddContactViewModel,
    contactID: String,
) {

    val context = LocalContext.current
    val name by viewModel.name.collectAsState("")
    val email by viewModel.email.collectAsState("")
    val phoneNo by viewModel.phoneNo.collectAsState(emptyList())
    val address by viewModel.address.collectAsState("")
    val imageUrl by viewModel.imageUrl.collectAsState("")
    val expanded by viewModel.expanded.observeAsState(initial = false)
    val (isComplete, setIsComplete) = remember {
        mutableStateOf(false)
    }
    val bloodGroupList by remember {
        mutableStateOf(context.resources.getStringArray(R.array.bloodGroupArray))
    }

    val bloodGroup by viewModel.bloodGroup.collectAsState()
    val contact by viewModel.selectedContact.collectAsState()
    if (contactID != "0") {
        viewModel.fetchContactById(contactID)
        contact?.let { viewModel.setValues(it) }
    } else {
        viewModel.apply {
            onNameChange("")
            onEmailChange("")
            onAddressChange("")
            onImageUrlChange("")
            onPhoneNumberChange(0, "")
            onBloodGroupChange(bloodGroupList[0])
        }
    }

    val launcher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let {
            viewModel.uploadImageToFirebase(it,
                onSuccess = { imageUrl ->
                    viewModel.onImageUrlChange(imageUrl)
                },
                onFailure = { exception ->
                    Toast.makeText(
                        context,
                        "Image upload failed: ${exception.message}",
                        Toast.LENGTH_SHORT
                    ).show()
                }
            )
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { },
                colors = TopAppBarDefaults.topAppBarColors(CustomBlue),
            )
        }
    ) { paddingValues ->
        LazyColumn(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize()
                .background(CustomGrey),
            verticalArrangement = Arrangement.Center
        ) {
            item {
                Box(
                    contentAlignment = Alignment.Center,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp, vertical = 8.dp)
                        .clickable {
                            launcher.launch("image/*")
                        }
                ) {
                    Image(
                        painter = if (imageUrl.isEmpty()) {
                            painterResource(id = R.drawable.add_photo)
                        } else {
                            rememberAsyncImagePainter(model = imageUrl)
                        },
                        contentScale = ContentScale.Crop,
                        contentDescription = "",
                        modifier = Modifier
                            .size(120.dp)
                            .padding(8.dp)
                            .border(1.dp, Color.DarkGray, CircleShape)
                            .clip(CircleShape)
                    )
                }
                Spacer(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(20.dp)
                )

                DetailTextFields(
                    value = name,
                    valueChange = { viewModel.onNameChange(it) },
                    label = stringResource(R.string.name),
                    keyboardOptions = KeyboardOptions.Default.copy(
                        imeAction = ImeAction.Next
                    )
                )

                DetailTextFields(
                    value = email,
                    valueChange = { viewModel.onEmailChange(it) },
                    label = stringResource(R.string.email),
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email).copy(
                        imeAction = ImeAction.Next
                    )
                )
                val addIcon = Icons.Default.Add
                val deleteIcon = Icons.Default.Delete

                phoneNo.forEachIndexed { index, phoneNo ->
                    DetailTextFields(
                        value = phoneNo,
                        valueChange = { viewModel.onPhoneNumberChange(index, it) },
                        label = stringResource(R.string.phone_no),
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number).copy(
                            imeAction = ImeAction.Next
                        ),
                        trailingIcon = {
                            Icon(
                                imageVector = if (index > 0) deleteIcon else addIcon,
                                contentDescription = "",
                                modifier = Modifier
                                    .padding(end = 8.dp)
                                    .size(32.dp)
                                    .clickable {
                                        when {
                                            addIcon == Icons.Default.Add -> if (index > 0) {
                                                viewModel.removePhoneNumberField()
                                            } else {
                                                viewModel.addPhoneNumberField()
                                            }
                                        }
                                    }
                            )
                        }
                    )
                }

                DetailTextFields(
                    value = address,
                    valueChange = { viewModel.onAddressChange(it) },
                    label = stringResource(R.string.address),
                    keyboardOptions = KeyboardOptions.Default.copy(
                        imeAction = ImeAction.Next
                    )
                )

                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier.padding(horizontal = 16.dp)
                ) {
                    Text(
                        fontWeight = FontWeight.Bold,
                        text = stringResource(R.string.select_blood_group),
                        style = MaterialTheme.typography.titleMedium,
                    )
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp)
                            .background(Color.LightGray)
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .border(1.dp, Color.Black)
                                .padding(4.dp)
                                .clickable { viewModel.onExpandedChange(true) },
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                textAlign = TextAlign.Center,
                                text = bloodGroup,
                                fontWeight = FontWeight.Bold,
                                modifier = Modifier
                                    .weight(1f)
                                    .padding(4.dp)
                            )
                            Icon(
                                Icons.Filled.ArrowDropDown,
                                contentDescription = "",
                                modifier = Modifier.padding(horizontal = 8.dp)
                            )
                        }
                        DropdownMenu(
                            expanded = expanded,
                            onDismissRequest = { viewModel.onExpandedChange(false) }
                        ) {
                            bloodGroupList.forEach { type ->
                                DropdownMenuItem(
                                    text = { Text(text = type, fontSize = 16.sp) },
                                    onClick = {
                                        viewModel.onBloodGroupChange(type)
                                        viewModel.onExpandedChange(false)
                                    }
                                )
                            }
                        }
                    }
                }
                SwipeButton(
                    text = if (contactID == "0") stringResource(R.string.btn_save) else stringResource(
                        R.string.btn_update
                    ),
                    isComplete = isComplete,
                    onSwipe = {
                        viewModel.verifyDetails(
                            contactID = if (contactID == "0") UUID.randomUUID()
                                .toString() else contactID,
                            name = name,
                            email = email,
                            phoneNumber = phoneNo,
                            profilePicture = imageUrl,
                            bloodGroup = bloodGroup,
                            address = address,
                            context = context,
                            navController = navController
                        )
                    }
                )
            }
        }
    }
}

@Composable
fun DetailTextFields(
    value: String,
    valueChange: (String) -> Unit,
    label: String,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    trailingIcon: @Composable (() -> Unit)? = null
) {
    TextField(
        colors = TextFieldDefaults.colors(
            focusedContainerColor = Color.LightGray,
            unfocusedContainerColor = Color.LightGray
        ),
        keyboardOptions = keyboardOptions,
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        value = value,
        onValueChange = valueChange,
        label = { Text(text = label) },
        trailingIcon = trailingIcon
    )
}

@Preview
@Composable
fun ContactAddScreenPreview() {
    AddContactScreen(
        NavHostController(LocalContext.current),
        AddContactViewModel(),
        "it"
    )
}

package com.example.contactkeeper.ui.components

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.animateContentSize
import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.requiredHeight
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.rounded.CheckCircle
import androidx.compose.material.icons.rounded.Done
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.wear.compose.material.CircularProgressIndicator
import androidx.wear.compose.material.ExperimentalWearMaterialApi
import androidx.wear.compose.material.FractionalThreshold
import androidx.wear.compose.material.Icon
import androidx.wear.compose.material.Text
import androidx.wear.compose.material.rememberSwipeableState
import androidx.wear.compose.material.swipeable
import com.example.contactkeeper.ui.theme.CustomBlue
import kotlin.math.roundToInt

@OptIn(ExperimentalWearMaterialApi::class)
@Composable
fun SwipeButton(
    text: String,
    isComplete: Boolean,
    modifier: Modifier = Modifier,
    doneImageVector: ImageVector = Icons.Rounded.Done,
    backgroundColor: Color = CustomBlue,
    onSwipe: () -> Boolean,
) {
    val width = 200.dp
    val widthInPx = with(LocalDensity.current) {
        width.toPx()
    }
    val anchors = mapOf(0F to 0, widthInPx to 1)
    val swipeableState = rememberSwipeableState(0)
    val (swipeComplete, setSwipeComplete) = remember {
        mutableStateOf(false)
    }
    val alpha: Float by animateFloatAsState(
        targetValue = if (swipeComplete) {
            0F
        } else {
            1F
        },
        animationSpec = tween(
            durationMillis = 300,
            easing = LinearEasing,
        ), label = ""
    )

    LaunchedEffect(
        key1 = swipeableState.currentValue,
    ) {
        if (swipeableState.currentValue == 1) {
            if (onSwipe()) {
                setSwipeComplete(true)
            } else {
                swipeableState.snapTo(0) // Reset to initial state if validation fails
            }
        }
    }

    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
            .padding(
                horizontal = 48.dp,
                vertical = 24.dp,
            )
            .clip(CircleShape)
            .background(backgroundColor)
            .animateContentSize()
            .then(
                if (swipeComplete) {
                    Modifier.width(64.dp)
                } else {
                    Modifier.fillMaxWidth()
                }
            )
            .requiredHeight(64.dp),
    ) {
        SwipeIndicator(
            modifier = Modifier
                .align(Alignment.CenterStart)
                .alpha(alpha)
                .offset {
                    IntOffset(swipeableState.offset.value.roundToInt(), 0)
                }
                .swipeable(
                    state = swipeableState,
                    anchors = anchors,
                    thresholds = { _, _ ->
                        FractionalThreshold(0.3F)
                    },
                    orientation = Orientation.Horizontal,
                ),
            backgroundColor = backgroundColor,
        )
        Text(
            text = text,
            color = Color.White,
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center,
            modifier = Modifier
                .fillMaxWidth()
                .alpha(alpha)
                .padding(horizontal = 80.dp)
                .offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }
        )
        AnimatedVisibility(visible = swipeComplete && !isComplete) {
            CircularProgressIndicator(
                indicatorColor = Color.White,
                strokeWidth = 1.dp,
                modifier = Modifier
                    .fillMaxSize()
                    .padding(4.dp)
                    .align(Alignment.Center)
            )
        }
        AnimatedVisibility(
            visible = isComplete,
            enter = fadeIn(),
            exit = fadeOut(),
        ) {
            Icon(
                imageVector = doneImageVector,
                contentDescription = null,
                tint = Color.White,
                modifier = Modifier
                    .align(Alignment.Center)
                    .size(44.dp),
            )
        }
    }
}

@Composable
fun SwipeIndicator(modifier: Modifier, backgroundColor: Color) {
    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
            .fillMaxHeight()
            .padding(2.dp)
            .border(1.dp, Color.Gray, CircleShape)
            .clip(CircleShape)
            .aspectRatio(
                ratio = 1.0F,
                matchHeightConstraintsFirst = true,
            )
            .background(Color.White),
    ) {
        Icon(
            imageVector = Icons.Rounded.CheckCircle,
            contentDescription = null,
            tint = backgroundColor,
            modifier = Modifier.size(36.dp),
        )
    }
}