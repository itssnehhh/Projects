getMessages Function
This function retrieves chat messages between a sender and a receiver, ordered by timestamp, and returns a Flow of a list of ChatMessage objects.

kotlin
Copy code
fun getMessages(senderEmail: String, receiverEmail: String): Flow<List<ChatMessage>> =
    callbackFlow {
        // Reference to the Firestore document for the sender and receiver
        val docRef = chatsCollection
            .document(senderEmail)
            .collection(receiverEmail)
            .orderBy("timestamp")

        // Add a snapshot listener to get real-time updates
        val subscription = docRef.addSnapshotListener { snapshot, _ ->
            if (snapshot != null) {
                // Convert the snapshot to a list of ChatMessage objects
                val messages = snapshot.toObjects(ChatMessage::class.java)
                // Send the list of messages to the flow
                trySend(messages).isSuccess
            }
        }

        // Clean up the listener when the flow is closed
        awaitClose { subscription.remove() }
    }
callbackFlow: Creates a flow that emits values using callbacks. In this case, it listens for changes in the Firestore database.
docRef: A reference to the Firestore collection of messages between the senderEmail and receiverEmail, ordered by timestamp.
addSnapshotListener: Adds a listener to get real-time updates when the data changes. When a change occurs, it retrieves the messages as ChatMessage objects and sends them to the flow.
awaitClose: Ensures the snapshot listener is removed when the flow is closed to prevent memory leaks.
sendMessage Function
This function sends a chat message from the current user to the receiver and stores it in both the sender's and receiver's Firestore collections.

kotlin
Copy code
fun sendMessage(receiverEmail: String, message: String, onResult: (Boolean) -> Unit) {
    val currentUser = FirebaseAuth.getInstance().currentUser
    val senderEmail = currentUser?.email ?: return

    // Generate a unique message ID
    val messageId = UUID.randomUUID().toString()
    // Create a ChatMessage object
    val chatMessage = ChatMessage(
        id = messageId,
        senderId = senderEmail,
        receiverId = receiverEmail,
        message = message,
        isSent = true,
        timestamp = System.currentTimeMillis()
    )

    // References to the Firestore documents for the sender and receiver
    val senderDocRef = chatsCollection
        .document(senderEmail)
        .collection(receiverEmail)
        .document(messageId)

    val receiverDocRef = chatsCollection
        .document(receiverEmail)
        .collection(senderEmail)
        .document(messageId)

    // Run a batch write to ensure both documents are updated atomically
    firestore.runBatch { batch ->
        batch.set(senderDocRef, chatMessage)
        batch.set(receiverDocRef, chatMessage)
    }.addOnCompleteListener { task ->
        // Notify the caller whether the operation was successful
        onResult(task.isSuccessful)
    }
}
currentUser: Retrieves the currently authenticated user from Firebase Auth.
senderEmail: Gets the email of the current user.
messageId: Generates a unique ID for the message using UUID.randomUUID().
chatMessage: Creates a ChatMessage object with the sender's email, receiver's email, message content, and the current timestamp.
senderDocRef and receiverDocRef: References to the Firestore documents for storing the message in both the sender's and receiver's collections.
runBatch: Runs a batch operation to ensure that both the sender's and receiver's documents are updated atomically. This ensures data consistency and that both users see the same message.