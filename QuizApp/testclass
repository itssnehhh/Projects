// Import statements
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.contactkeeper.data.firestore.FireStoreService
import com.example.contactkeeper.data.model.Contact
import com.google.firebase.storage.FirebaseStorage
import com.google.firebase.storage.StorageReference
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.test.TestCoroutineDispatcher
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TestRule
import org.mockito.Mock
import org.mockito.Mockito.*
import org.mockito.MockitoAnnotations

@ExperimentalCoroutinesApi
class HomeViewModelTest {

    @get:Rule
    var rule: TestRule = InstantTaskExecutorRule()

    private val testDispatcher = TestCoroutineDispatcher()

    @Mock
    private lateinit var fireStoreService: FireStoreService

    @Mock
    private lateinit var firebaseStorage: FirebaseStorage

    private lateinit var homeViewModel: HomeViewModel

    @Before
    fun setup() {
        MockitoAnnotations.initMocks(this)
        Dispatchers.setMain(testDispatcher)
        homeViewModel = HomeViewModel(fireStoreService)
    }

    @Test
    fun `getContactList should fetch contacts and update state`() = testDispatcher.runBlockingTest {
        // Given
        val contactList = listOf(Contact(id = "1", name = "John Doe", phone = "1234567890"))
        `when`(fireStoreService.getContacts()).thenReturn(flow { emit(contactList) })

        // When
        homeViewModel.getContactList()

        // Then
        assertEquals(contactList, homeViewModel.contacts.value)
        assertEquals(false, homeViewModel.isLoading.value)
    }

    @Test
    fun `deleteContact should call FireStoreService deleteContact`() = testDispatcher.runBlockingTest {
        // Given
        val contactId = "1"

        // When
        homeViewModel.deleteContact(contactId)

        // Then
        verify(fireStoreService).deleteContact(contactId)
    }

    @Test
    fun `deleteImageFromFirebase should delete image from Firebase`() {
        // Given
        val imageUrl = "https://example.com/image.jpg"
        val storageReference: StorageReference = mock(StorageReference::class.java)
        `when`(firebaseStorage.getReferenceFromUrl(imageUrl)).thenReturn(storageReference)

        // When
        homeViewModel.deleteImageFromFirebase(imageUrl)

        // Then
        verify(storageReference).delete()
    }
}


package com.example.contactkeeper.ui.screen.detail

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.example.contactkeeper.data.firestore.FireStoreService
import com.example.contactkeeper.data.model.Contact
import io.mockk.coEvery
import io.mockk.mockk
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TestRule

@ExperimentalCoroutinesApi
class DetailViewModelTest {

    @get:Rule
    var rule: TestRule = InstantTaskExecutorRule()

    private lateinit var viewModel: DetailViewModel
    private lateinit var fireStoreService: FireStoreService

    @Before
    fun setup() {
        fireStoreService = mockk()
        viewModel = DetailViewModel()
    }

    @Test
    fun `test getUserList function`() = runBlockingTest {
        val mockContacts = listOf(
            Contact("1", "John Doe", "john@example.com"),
            Contact("2", "Jane Doe", "jane@example.com")
        )
        val contactsFlow = MutableStateFlow(mockContacts)

        coEvery { fireStoreService.getContacts() } returns contactsFlow

        viewModel.getUserList()

        val collectedContacts = viewModel.contacts.toList()
        assertEquals(mockContacts, collectedContacts.first())
    }

    @Test
    fun `test fetchContactById function`() = runBlockingTest {
        val mockContacts = listOf(
            Contact("1", "John Doe", "john@example.com"),
            Contact("2", "Jane Doe", "jane@example.com")
        )
        viewModel._contacts.value = mockContacts

        viewModel.fetchContactById("1")

        assertEquals(mockContacts[0], viewModel.selectedContact.value)
    }

    @Test
    fun `test deleteContact function`() = runBlockingTest {
        val contactId = "1"

        coEvery { fireStoreService.deleteContact(contactId) } returns Unit

        viewModel.deleteContact(contactId)

        // No further assertions needed here as deleteContact doesn't update any StateFlow
    }

    @Test
    fun `test onDialogStatusChange function`() {
        viewModel.onDialogStatusChange(true)
        assertEquals(true, viewModel.showDialog.value)

        viewModel.onDialogStatusChange(false)
        assertEquals(false, viewModel.showDialog.value)
    }
}


package com.example.contactkeeper.ui.screen.addScreen

import android.content.Context
import android.net.Uri
import android.util.Patterns
import android.widget.Toast
import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import androidx.lifecycle.Observer
import androidx.navigation.NavHostController
import com.example.contactkeeper.R
import com.example.contactkeeper.data.firestore.FireStoreService
import com.example.contactkeeper.data.model.Contact
import io.mockk.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.runBlockingTest
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TestRule
import java.util.*

@ExperimentalCoroutinesApi
class AddContactViewModelTest {

    @get:Rule
    var rule: TestRule = InstantTaskExecutorRule()

    private lateinit var viewModel: AddContactViewModel
    private lateinit var fireStoreService: FireStoreService
    private lateinit var context: Context
    private lateinit var navController: NavHostController

    @Before
    fun setup() {
        fireStoreService = mockk()
        context = mockk()
        navController = mockk()
        viewModel = AddContactViewModel()
    }

    @Test
    fun `test onNameChange function`() {
        val newName = "John Doe"
        viewModel.onNameChange(newName)
        assertEquals(newName, viewModel.name.value)
    }

    @Test
    fun `test onEmailChange function`() {
        val newEmail = "john@example.com"
        viewModel.onEmailChange(newEmail)
        assertEquals(newEmail, viewModel.email.value)
    }

    @Test
    fun `test onPhoneNumberChange function`() {
        val newPhoneNo = "1234567890"
        viewModel.onPhoneNumberChange(0, newPhoneNo)
        assertEquals(listOf(newPhoneNo), viewModel.phoneNo.value)
    }

    @Test
    fun `test addPhoneNumberField function`() {
        viewModel.addPhoneNumberField()
        assertEquals(listOf(""), viewModel.phoneNo.value)
    }

    @Test
    fun `test removePhoneNumberField function`() {
        viewModel.addPhoneNumberField()
        viewModel.removePhoneNumberField()
        assertEquals(listOf(""), viewModel.phoneNo.value)
    }

    @Test
    fun `test onAddressChange function`() {
        val newAddress = "123 Main St"
        viewModel.onAddressChange(newAddress)
        assertEquals(newAddress, viewModel.address.value)
    }

    @Test
    fun `test onImageUrlChange function`() {
        val newImageUrl = "http://example.com/image.jpg"
        viewModel.onImageUrlChange(newImageUrl)
        assertEquals(newImageUrl, viewModel.imageUrl.value)
    }

    @Test
    fun `test onBloodGroupChange function`() {
        val newBloodGroup = "B+"
        viewModel.onBloodGroupChange(newBloodGroup)
        assertEquals(newBloodGroup, viewModel.bloodGroup.value)
    }

    @Test
    fun `test onExpandedChange function`() {
        val observer: Observer<Boolean> = mockk(relaxed = true)
        viewModel.expanded.observeForever(observer)

        viewModel.onExpandedChange(true)
        assertEquals(true, viewModel.expanded.value)

        viewModel.onExpandedChange(false)
        assertEquals(false, viewModel.expanded.value)

        viewModel.expanded.removeObserver(observer)
    }

    @Test
    fun `test fetchContactById function`() = runBlockingTest {
        val mockContacts = listOf(
            Contact("1", "John Doe", "john@example.com"),
            Contact("2", "Jane Doe", "jane@example.com")
        )
        val contactsFlow = MutableStateFlow(mockContacts)

        coEvery { fireStoreService.getContacts() } returns contactsFlow

        viewModel.fetchContactById("1")

        val collectedContacts = viewModel.selectedContact.toList()
        assertEquals(mockContacts[0], collectedContacts.first())
    }

    @Test
    fun `test setValues function`() {
        val contact = Contact(
            id = "1",
            name = "John Doe",
            email = "john@example.com",
            phoneNumber = listOf("1234567890"),
            profilePicture = "http://example.com/image.jpg",
            bloodGroup = "A+",
            address = "123 Main St"
        )
        viewModel.setValues(contact)
        assertEquals(contact.name, viewModel.name.value)
        assertEquals(contact.email, viewModel.email.value)
        assertEquals(contact.phoneNumber, viewModel.phoneNo.value)
        assertEquals(contact.profilePicture, viewModel.imageUrl.value)
        assertEquals(contact.bloodGroup, viewModel.bloodGroup.value)
        assertEquals(contact.address, viewModel.address.value)
    }

    @Test
    fun `test verifyDetails function with valid details`() {
        val name = "John Doe"
        val email = "john@example.com"
        val phoneNumber = listOf("1234567890")
        val profilePicture = "http://example.com/image.jpg"
        val bloodGroup = "A+"
        val address = "123 Main St"

        every { context.getString(R.string.empty_toast) } returns "Please fill in all fields"
        every { context.getString(R.string.invalid_email_toast) } returns "Please enter a valid email"
        every { context.getString(R.string.invalid_contact_toast) } returns "Please enter a valid phone number"
        every { context.getString(R.string.save_toast) } returns "Contact saved"
        every { Toast.makeText(context, any<String>(), any()).show() } just Runs
        every { navController.popBackStack() } just Runs

        val result = viewModel.verifyDetails(
            "0", name, email, phoneNumber, profilePicture, bloodGroup, address, context, navController
        )

        assertEquals(true, result)
    }

    @Test
    fun `test verifyDetails function with invalid email`() {
        val name = "John Doe"
        val email = "invalid_email"
        val phoneNumber = listOf("1234567890")
        val profilePicture = "http://example.com/image.jpg"
        val bloodGroup = "A+"
        val address = "123 Main St"

        every { context.getString(R.string.invalid_email_toast) } returns "Please enter a valid email"
        every { Toast.makeText(context, any<String>(), any()).show() } just Runs

        val result = viewModel.verifyDetails(
            "0", name, email, phoneNumber, profilePicture, bloodGroup, address, context, navController
        )

        assertEquals(false, result)
    }
}