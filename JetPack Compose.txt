1. Dao
@Dao
interface EmployeeDao {

    @Insert
    suspend fun insert(employee: Employee)

    @Query("SELECT * FROM employee")
    fun getAllEmployees(): Flow<List<Employee>>
}

2. Database
@Database(entities = [Employee::class], version = 1, exportSchema = false)
abstract class EmployeeDatabase : RoomDatabase() {
    abstract fun employeeDao(): EmployeeDao

    companion object {
        @Volatile
        private var INSTANCE: EmployeeDatabase? = null

        fun getDatabase(context: Context): EmployeeDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    EmployeeDatabase::class.java,
                    "employee_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}

3. Repository
class EmployeeRepository(private val employeeDao: EmployeeDao) {

    fun getAllEmployees(): Flow<List<Employee>> {
        return employeeDao.getAllEmployees()
    }

    suspend fun insert(employee: Employee) {
        employeeDao.insert(employee)
    }
}

4. ADD EMployee SCreen
@Composable
fun AddEmployeeScreen(
    viewModel: EmployeeViewModel = viewModel(),
    navHostController: NavHostController,
) {
    val name = rememberSaveable { mutableStateOf("") }
    val email = rememberSaveable { mutableStateOf("") }
    val contactInfo = rememberSaveable { mutableStateOf("") }
    val jobTitle = rememberSaveable { mutableStateOf("") }
    val address = rememberSaveable { mutableStateOf("") }
    val dob = rememberSaveable { mutableStateOf("") }
    val bloodGroup = rememberSaveable { mutableStateOf("") }

    Column(modifier = Modifier.padding(16.dp)) {
        OutlinedTextField(
            value = name.value,
            onValueChange = { name.value = it },
            label = { Text("Name") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        OutlinedTextField(
            value = email.value,
            onValueChange = { email.value = it },
            label = { Text("Email") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        OutlinedTextField(
            value = contactInfo.value,
            onValueChange = { contactInfo.value = it },
            label = { Text("Contact Info") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        OutlinedTextField(
            value = jobTitle.value,
            onValueChange = { jobTitle.value = it },
            label = { Text("Job Title") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        OutlinedTextField(
            value = address.value,
            onValueChange = { address.value = it },
            label = { Text("Address") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        OutlinedTextField(
            value = dob.value,
            onValueChange = { dob.value = it },
            label = { Text("Date of Birth") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        OutlinedTextField(
            value = bloodGroup.value,
            onValueChange = { bloodGroup.value = it },
            label = { Text("Blood Group") },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 4.dp)
        )
        Button(
            onClick = {
                viewModel.name = name.value
                viewModel.email = email.value
                viewModel.contactInfo = contactInfo.value
                viewModel.jobTitle = jobTitle.value
                viewModel.address = address.value
                viewModel.dob = dob.value
                viewModel.bloodGroup = bloodGroup.value
                viewModel.saveEmployee()
                navHostController.navigate(EMPLOYEE_SCREEN)
            },
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp)
        ) {
            Text("Save Employee")
        }
    }
}

@Preview
@Composable
fun AddEmployeeCardPreview() {
    AddEmployeeScreen(
        EmployeeViewModel(Application()),
        NavHostController(LocalContext.current)
    )
}

5. ViewModel EMployee
class EmployeeViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: EmployeeRepository

    val employees: StateFlow<List<Employee>>

    var name by mutableStateOf("")
    var email by mutableStateOf("")
    var contactInfo by mutableStateOf("")
    var jobTitle by mutableStateOf("")
    var address by mutableStateOf("")
    var dob by mutableStateOf("")
    var bloodGroup by mutableStateOf("")

    init {
        val employeeDao = EmployeeDatabase.getDatabase(application).employeeDao()
        repository = EmployeeRepository(employeeDao)
        employees = repository.getAllEmployees().stateIn(viewModelScope, SharingStarted.Lazily, emptyList())
    }

    fun saveEmployee() {
        viewModelScope.launch {
            val employee = Employee(
                name = name,
                email = email,
                contactInfo = contactInfo,
                jobTitle = jobTitle,
                address = address,
                dob = dob,
                bloodGroup = bloodGroup
            )
            repository.insert(employee)
        }
    }
}

6. Employee Screen
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployeeScreen(navController: NavHostController) {

    val viewModel: EmployeeViewModel = viewModel()
    val employees by viewModel.employees.collectAsState()


    Scaffold(
        topBar = {
            TopAppBar(
                colors = TopAppBarDefaults.topAppBarColors(Color(0xFF854EE6)),
                title = {
                    Text(
                        color = Color.White,
                        text = stringResource(R.string.employee_list),
                        fontWeight = FontWeight.Bold,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { navController.navigate(ADD_EMPLOYEE_SCREEN) },
                modifier = Modifier.padding(16.dp),
                containerColor = Color(0xFF6F41C0)
            ) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "")
            }
        }
    ) {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(it)
                .background(MaterialTheme.colorScheme.onSurface)
        ) {

        }
    }

}

@Composable
fun EmployeeCard(){

}


@Preview
@Composable
fun EmployeeScreenPreview() {
    EmployeeScreen(navController = NavHostController(LocalContext.current))
}


7. Notification Screen
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NotificationScreen(viewModel: NotificationViewModel) {
    val notifications by viewModel.notifications.observeAsState(emptyList())
    Scaffold(
        topBar = {
            TopAppBar(
                colors = TopAppBarDefaults.topAppBarColors(Color(0xFF854EE6)),
                title = {
                    Text(
                        color = Color.White,
                        text = stringResource(R.string.notification_screen),
                        fontWeight = FontWeight.Bold,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.fillMaxWidth()
                    )
                })
        }
    ) {
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(it)
                .background(MaterialTheme.colorScheme.onSurface)
        ) {
            items(notifications) { notification ->
                NotificationCard(
                    type = notification.type,
                    title = notification.title,
                    notification = notification.message
                )
            }
        }
    }
}

@Composable
fun NotificationCard(type: String, title: String, notification: String) {
    Card(
        elevation = CardDefaults.cardElevation(4.dp),
        colors = CardDefaults.cardColors(Color(0xFFBC9CF5)),
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp, horizontal = 8.dp)
            .border(1.dp, Color.Black, CardDefaults.shape)
    ) {
        Row(
            modifier = Modifier.padding(8.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Image(
                painter = painterResource(id = R.drawable.notifications),
                contentDescription = "",
                modifier = Modifier
                    .size(32.dp)
                    .clip(CircleShape)
            )
            Column {
                Text(
                    color = MaterialTheme.colorScheme.onSecondary,
                    text = type,
                    style = MaterialTheme.typography.titleMedium,
                    maxLines = 1,
                    modifier = Modifier.padding(start = 12.dp)
                )
                Text(
                    text = "$title :- $notification",
                    style = MaterialTheme.typography.bodyMedium,
                    maxLines = 3,
                    modifier = Modifier.padding(start = 12.dp, top = 4.dp)
                )
            }
        }
    }
}

@Preview
@Composable
fun NotificationScreenPreview() {
    NotificationScreen(NotificationViewModel(LocalContext.current))
}


8. Notification ViewModel
class NotificationViewModel(context: Context):ViewModel() {

    private val _notifications = MutableLiveData<List<Notification>>()
    val notifications: LiveData<List<Notification>> = _notifications

    init {
        val notificationTypeList = context.resources.getStringArray(R.array.notificationTypeList)
        val notificationTitleList = context.resources.getStringArray(R.array.notificationTitleList)
        val notificationList = context.resources.getStringArray(R.array.notificationList)

        val notifications = notificationTypeList.indices.map { index ->
            Notification(
                type = notificationTypeList[index],
                title = notificationTitleList[index],
                message = notificationList[index]
            )
        }

        _notifications.value = notifications
    }
}

9. Notifications
    <string-array name="notificationTypeList">
        <item>Announcement</item>
        <item>Reminder</item>
        <item>Alert</item>
        <item>Announcement</item>
        <item>Reminder</item>
        <item>Alert</item>
        <item>Announcement</item>
        <item>Reminder</item>
    </string-array>

    <string-array name="notificationTitleList">
        <item>New Company Policy</item>
        <item>Timesheet Submission</item>
        <item>System Maintenance</item>
        <item>Office Closure</item>
        <item>Performance Reviews</item>
        <item>Security Update</item>
        <item>Team Meeting</item>
        <item>Project Deadline</item>
    </string-array>

    <string-array name="notificationList">
        <item>Please review the new company policy on remote work.</item>
        <item>Submit your timesheet by end of the day.</item>
        <item>The system will be down for maintenance on 2024–06–05 from 02:00 to 04:00 UTC.</item>
        <item>The office will be closed on 2024–06–10 for a public holiday.</item>
        <item>Annual performance reviews are scheduled for next week.</item>
        <item>A critical security update will be applied tonight. Please save your work.</item>
        <item>Team meeting scheduled for 2024–06–07 at 10:00 AM in Conference Room A.</item>
        <item>The project deadline is approaching. Ensure all tasks are completed by 2024–06–15.</item>
    </string-array>

10. Main Screen
@Composable
fun MainScreen() {
    val navController = rememberNavController()
    Scaffold(
        bottomBar = { BottomNavigationBar(navController = navController) },
        content = { paddingValues ->
            NavHostController(navController = navController, paddingValues = paddingValues)
        }
    )
}

@Composable
fun NavHostController(
    navController: NavHostController,
    paddingValues: PaddingValues,
) {
    NavHost(
        navController = navController,
        startDestination = HOME_SCREEN,
        modifier = Modifier.padding(paddingValues),
        builder = {
            composable(HOME_SCREEN) {
                HomeScreen()
            }
            composable(EMPLOYEE_SCREEN) {
                EmployeeScreen(navController)
            }
            composable(NOTIFICATION_SCREEN) {
                val context = LocalContext.current
                val viewModel =  NotificationViewModel(context)
                NotificationScreen(viewModel)
            }
            composable(PROFILE_SCREEN) {
                ProfileScreen()
            }
            composable(ADD_EMPLOYEE_SCREEN){
                val viewModel =  EmployeeViewModel(Application())
                AddEmployeeScreen(viewModel,navController)
            }
        }
    )
}

@Composable
fun BottomNavigationBar(navController: NavHostController) {

    val bottomNavItems = listOf(
        BottomNavItem(
            label = "Home",
            icon = Icons.Default.Home,
            route = HOME_SCREEN
        ),
        BottomNavItem(
            label = "Employee",
            icon = Icons.Default.List,
            route = EMPLOYEE_SCREEN
        ),
        BottomNavItem(
            label = "Notification",
            icon = Icons.Default.Notifications,
            route = NOTIFICATION_SCREEN,
        ),
        BottomNavItem(
            label = "Profile",
            icon = Icons.Default.Person,
            route = PROFILE_SCREEN
        )
    )

    BottomAppBar {
        val navBackStackEntry by navController.currentBackStackEntryAsState()
        val currentRoute = navBackStackEntry?.destination?.route
        bottomNavItems.forEach { navItem ->
            NavigationBarItem(
                selected = currentRoute == navItem.route,
                onClick = { navController.navigate(navItem.route) },
                icon = { Icon(imageVector = navItem.icon, contentDescription = navItem.label) },
                label = { Text(text = navItem.label) },
                alwaysShowLabel = true
            )
        }
    }
}